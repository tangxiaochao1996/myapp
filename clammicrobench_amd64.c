#define _GNU_SOURCE
#include <stdio.h>
#include<stdint.h>
#include<sys/time.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#pragma GCC diagnostic ignored "-Wattributes"
// this is a partial C file that's appended into generated code
// stuff here is generic enough to work for both windows/vs and gcc

#ifndef __MINGW32__
// optional affinity setting for effed up qualcomm/android bs
#include <sched.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <pthread.h>

void setAffinity(int core) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core, &cpuset);
    printf("Set affinity to core %d\n", core);
    // sched_setaffinity(gettid(), sizeof(cpu_set_t), &cpuset);
}
#endif

struct ThreadData {
    int* A;
    int* B;
    float* fpArr;
    uint32_t list_size;
    uint64_t structIterations;
};

void printCsvHeader(uint32_t* xCounts, uint32_t xLen) {
    printf("x");
    for (uint32_t testSizeIdx = 0; testSizeIdx < xLen; testSizeIdx++) {
        printf(", %d", xCounts[testSizeIdx]);
    }

    printf("\n");
}

// print results in format that excel can take
void printResultFloatArr(float* arr, uint32_t *xCounts, uint32_t xLen, uint32_t *yCounts, uint32_t yLen) {
    uint32_t testSizeCount = xLen;
    printCsvHeader(xCounts, xLen);
    for (uint32_t branchCountIdx = 0; branchCountIdx < yLen; branchCountIdx++) {
        // row header
        printf("%d", yCounts[branchCountIdx]);
        for (uint32_t testSizeIdx = 0; testSizeIdx < testSizeCount; testSizeIdx++) {
            printf(",%f", arr[branchCountIdx * testSizeCount + testSizeIdx]);
        }

        printf("\n");
    }
}

void FillPatternArr(uint32_t* pattern_arr, uint32_t list_size, uint32_t byte_increment) {
    uint32_t increment = byte_increment / sizeof(uint32_t);
    uint32_t element_count = list_size / increment;
    for (int i = 0; i < element_count; i++) {
        pattern_arr[i * increment] = i * increment;
    }

    int iter = element_count;
    while (iter > 1) {
        iter -= 1;
        int j = iter - 1 == 0 ? 0 : rand() % (iter - 1);
        uint32_t tmp = pattern_arr[iter * increment];
        pattern_arr[iter * increment] = pattern_arr[j * increment];
        pattern_arr[j * increment] = tmp;
    }
}
extern uint64_t rob1(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1(structIterations, A);
}
extern uint64_t rob2(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob2(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob2(structIterations, A);
}
extern uint64_t rob3(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob3(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob3(structIterations, A);
}
extern uint64_t rob4(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob4(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob4(structIterations, A);
}
extern uint64_t rob5(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob5(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob5(structIterations, A);
}
extern uint64_t rob6(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob6(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob6(structIterations, A);
}
extern uint64_t rob7(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob7(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob7(structIterations, A);
}
extern uint64_t rob8(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob8(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob8(structIterations, A);
}
extern uint64_t rob9(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob9(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob9(structIterations, A);
}
extern uint64_t rob10(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob10(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob10(structIterations, A);
}
extern uint64_t rob11(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob11(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob11(structIterations, A);
}
extern uint64_t rob12(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob12(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob12(structIterations, A);
}
extern uint64_t rob13(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob13(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob13(structIterations, A);
}
extern uint64_t rob14(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob14(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob14(structIterations, A);
}
extern uint64_t rob15(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob15(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob15(structIterations, A);
}
extern uint64_t rob16(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob16(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob16(structIterations, A);
}
extern uint64_t rob17(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob17(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob17(structIterations, A);
}
extern uint64_t rob18(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob18(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob18(structIterations, A);
}
extern uint64_t rob19(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob19(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob19(structIterations, A);
}
extern uint64_t rob20(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob20(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob20(structIterations, A);
}
extern uint64_t rob21(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob21(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob21(structIterations, A);
}
extern uint64_t rob22(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob22(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob22(structIterations, A);
}
extern uint64_t rob23(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob23(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob23(structIterations, A);
}
extern uint64_t rob24(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob24(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob24(structIterations, A);
}
extern uint64_t rob25(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob25(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob25(structIterations, A);
}
extern uint64_t rob26(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob26(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob26(structIterations, A);
}
extern uint64_t rob27(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob27(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob27(structIterations, A);
}
extern uint64_t rob28(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob28(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob28(structIterations, A);
}
extern uint64_t rob29(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob29(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob29(structIterations, A);
}
extern uint64_t rob30(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob30(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob30(structIterations, A);
}
extern uint64_t rob31(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob31(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob31(structIterations, A);
}
extern uint64_t rob32(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob32(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob32(structIterations, A);
}
extern uint64_t rob33(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob33(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob33(structIterations, A);
}
extern uint64_t rob34(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob34(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob34(structIterations, A);
}
extern uint64_t rob35(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob35(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob35(structIterations, A);
}
extern uint64_t rob36(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob36(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob36(structIterations, A);
}
extern uint64_t rob37(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob37(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob37(structIterations, A);
}
extern uint64_t rob38(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob38(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob38(structIterations, A);
}
extern uint64_t rob39(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob39(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob39(structIterations, A);
}
extern uint64_t rob40(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob40(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob40(structIterations, A);
}
extern uint64_t rob41(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob41(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob41(structIterations, A);
}
extern uint64_t rob42(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob42(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob42(structIterations, A);
}
extern uint64_t rob43(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob43(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob43(structIterations, A);
}
extern uint64_t rob44(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob44(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob44(structIterations, A);
}
extern uint64_t rob45(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob45(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob45(structIterations, A);
}
extern uint64_t rob46(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob46(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob46(structIterations, A);
}
extern uint64_t rob47(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob47(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob47(structIterations, A);
}
extern uint64_t rob48(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob48(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob48(structIterations, A);
}
extern uint64_t rob49(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob49(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob49(structIterations, A);
}
extern uint64_t rob50(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob50(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob50(structIterations, A);
}
extern uint64_t rob51(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob51(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob51(structIterations, A);
}
extern uint64_t rob52(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob52(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob52(structIterations, A);
}
extern uint64_t rob53(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob53(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob53(structIterations, A);
}
extern uint64_t rob54(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob54(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob54(structIterations, A);
}
extern uint64_t rob55(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob55(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob55(structIterations, A);
}
extern uint64_t rob56(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob56(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob56(structIterations, A);
}
extern uint64_t rob57(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob57(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob57(structIterations, A);
}
extern uint64_t rob58(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob58(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob58(structIterations, A);
}
extern uint64_t rob59(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob59(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob59(structIterations, A);
}
extern uint64_t rob60(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob60(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob60(structIterations, A);
}
extern uint64_t rob61(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob61(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob61(structIterations, A);
}
extern uint64_t rob62(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob62(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob62(structIterations, A);
}
extern uint64_t rob63(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob63(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob63(structIterations, A);
}
extern uint64_t rob64(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob64(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob64(structIterations, A);
}
extern uint64_t rob65(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob65(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob65(structIterations, A);
}
extern uint64_t rob66(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob66(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob66(structIterations, A);
}
extern uint64_t rob67(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob67(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob67(structIterations, A);
}
extern uint64_t rob68(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob68(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob68(structIterations, A);
}
extern uint64_t rob69(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob69(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob69(structIterations, A);
}
extern uint64_t rob70(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob70(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob70(structIterations, A);
}
extern uint64_t rob71(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob71(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob71(structIterations, A);
}
extern uint64_t rob72(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob72(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob72(structIterations, A);
}
extern uint64_t rob73(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob73(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob73(structIterations, A);
}
extern uint64_t rob74(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob74(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob74(structIterations, A);
}
extern uint64_t rob75(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob75(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob75(structIterations, A);
}
extern uint64_t rob76(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob76(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob76(structIterations, A);
}
extern uint64_t rob77(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob77(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob77(structIterations, A);
}
extern uint64_t rob78(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob78(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob78(structIterations, A);
}
extern uint64_t rob79(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob79(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob79(structIterations, A);
}
extern uint64_t rob80(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob80(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob80(structIterations, A);
}
extern uint64_t rob81(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob81(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob81(structIterations, A);
}
extern uint64_t rob82(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob82(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob82(structIterations, A);
}
extern uint64_t rob83(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob83(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob83(structIterations, A);
}
extern uint64_t rob84(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob84(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob84(structIterations, A);
}
extern uint64_t rob85(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob85(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob85(structIterations, A);
}
extern uint64_t rob86(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob86(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob86(structIterations, A);
}
extern uint64_t rob87(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob87(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob87(structIterations, A);
}
extern uint64_t rob88(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob88(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob88(structIterations, A);
}
extern uint64_t rob89(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob89(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob89(structIterations, A);
}
extern uint64_t rob90(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob90(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob90(structIterations, A);
}
extern uint64_t rob91(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob91(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob91(structIterations, A);
}
extern uint64_t rob92(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob92(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob92(structIterations, A);
}
extern uint64_t rob93(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob93(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob93(structIterations, A);
}
extern uint64_t rob94(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob94(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob94(structIterations, A);
}
extern uint64_t rob95(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob95(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob95(structIterations, A);
}
extern uint64_t rob96(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob96(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob96(structIterations, A);
}
extern uint64_t rob97(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob97(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob97(structIterations, A);
}
extern uint64_t rob98(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob98(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob98(structIterations, A);
}
extern uint64_t rob99(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob99(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob99(structIterations, A);
}
extern uint64_t rob100(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob100(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob100(structIterations, A);
}
extern uint64_t rob101(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob101(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob101(structIterations, A);
}
extern uint64_t rob102(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob102(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob102(structIterations, A);
}
extern uint64_t rob103(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob103(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob103(structIterations, A);
}
extern uint64_t rob104(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob104(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob104(structIterations, A);
}
extern uint64_t rob105(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob105(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob105(structIterations, A);
}
extern uint64_t rob106(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob106(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob106(structIterations, A);
}
extern uint64_t rob107(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob107(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob107(structIterations, A);
}
extern uint64_t rob108(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob108(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob108(structIterations, A);
}
extern uint64_t rob109(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob109(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob109(structIterations, A);
}
extern uint64_t rob110(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob110(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob110(structIterations, A);
}
extern uint64_t rob111(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob111(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob111(structIterations, A);
}
extern uint64_t rob112(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob112(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob112(structIterations, A);
}
extern uint64_t rob113(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob113(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob113(structIterations, A);
}
extern uint64_t rob114(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob114(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob114(structIterations, A);
}
extern uint64_t rob115(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob115(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob115(structIterations, A);
}
extern uint64_t rob116(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob116(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob116(structIterations, A);
}
extern uint64_t rob117(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob117(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob117(structIterations, A);
}
extern uint64_t rob118(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob118(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob118(structIterations, A);
}
extern uint64_t rob119(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob119(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob119(structIterations, A);
}
extern uint64_t rob120(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob120(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob120(structIterations, A);
}
extern uint64_t rob121(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob121(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob121(structIterations, A);
}
extern uint64_t rob122(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob122(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob122(structIterations, A);
}
extern uint64_t rob123(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob123(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob123(structIterations, A);
}
extern uint64_t rob124(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob124(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob124(structIterations, A);
}
extern uint64_t rob125(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob125(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob125(structIterations, A);
}
extern uint64_t rob126(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob126(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob126(structIterations, A);
}
extern uint64_t rob127(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob127(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob127(structIterations, A);
}
extern uint64_t rob128(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob128(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob128(structIterations, A);
}
extern uint64_t rob129(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob129(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob129(structIterations, A);
}
extern uint64_t rob130(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob130(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob130(structIterations, A);
}
extern uint64_t rob131(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob131(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob131(structIterations, A);
}
extern uint64_t rob132(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob132(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob132(structIterations, A);
}
extern uint64_t rob133(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob133(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob133(structIterations, A);
}
extern uint64_t rob134(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob134(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob134(structIterations, A);
}
extern uint64_t rob135(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob135(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob135(structIterations, A);
}
extern uint64_t rob136(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob136(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob136(structIterations, A);
}
extern uint64_t rob137(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob137(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob137(structIterations, A);
}
extern uint64_t rob138(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob138(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob138(structIterations, A);
}
extern uint64_t rob139(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob139(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob139(structIterations, A);
}
extern uint64_t rob140(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob140(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob140(structIterations, A);
}
extern uint64_t rob141(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob141(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob141(structIterations, A);
}
extern uint64_t rob142(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob142(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob142(structIterations, A);
}
extern uint64_t rob143(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob143(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob143(structIterations, A);
}
extern uint64_t rob144(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob144(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob144(structIterations, A);
}
extern uint64_t rob145(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob145(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob145(structIterations, A);
}
extern uint64_t rob146(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob146(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob146(structIterations, A);
}
extern uint64_t rob147(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob147(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob147(structIterations, A);
}
extern uint64_t rob148(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob148(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob148(structIterations, A);
}
extern uint64_t rob149(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob149(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob149(structIterations, A);
}
extern uint64_t rob150(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob150(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob150(structIterations, A);
}
extern uint64_t rob151(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob151(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob151(structIterations, A);
}
extern uint64_t rob152(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob152(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob152(structIterations, A);
}
extern uint64_t rob153(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob153(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob153(structIterations, A);
}
extern uint64_t rob154(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob154(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob154(structIterations, A);
}
extern uint64_t rob155(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob155(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob155(structIterations, A);
}
extern uint64_t rob156(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob156(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob156(structIterations, A);
}
extern uint64_t rob157(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob157(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob157(structIterations, A);
}
extern uint64_t rob158(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob158(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob158(structIterations, A);
}
extern uint64_t rob159(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob159(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob159(structIterations, A);
}
extern uint64_t rob160(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob160(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob160(structIterations, A);
}
extern uint64_t rob161(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob161(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob161(structIterations, A);
}
extern uint64_t rob162(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob162(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob162(structIterations, A);
}
extern uint64_t rob163(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob163(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob163(structIterations, A);
}
extern uint64_t rob164(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob164(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob164(structIterations, A);
}
extern uint64_t rob165(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob165(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob165(structIterations, A);
}
extern uint64_t rob166(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob166(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob166(structIterations, A);
}
extern uint64_t rob167(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob167(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob167(structIterations, A);
}
extern uint64_t rob168(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob168(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob168(structIterations, A);
}
extern uint64_t rob169(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob169(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob169(structIterations, A);
}
extern uint64_t rob170(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob170(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob170(structIterations, A);
}
extern uint64_t rob171(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob171(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob171(structIterations, A);
}
extern uint64_t rob172(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob172(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob172(structIterations, A);
}
extern uint64_t rob173(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob173(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob173(structIterations, A);
}
extern uint64_t rob174(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob174(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob174(structIterations, A);
}
extern uint64_t rob175(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob175(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob175(structIterations, A);
}
extern uint64_t rob176(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob176(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob176(structIterations, A);
}
extern uint64_t rob177(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob177(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob177(structIterations, A);
}
extern uint64_t rob178(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob178(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob178(structIterations, A);
}
extern uint64_t rob179(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob179(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob179(structIterations, A);
}
extern uint64_t rob180(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob180(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob180(structIterations, A);
}
extern uint64_t rob181(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob181(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob181(structIterations, A);
}
extern uint64_t rob182(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob182(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob182(structIterations, A);
}
extern uint64_t rob183(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob183(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob183(structIterations, A);
}
extern uint64_t rob184(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob184(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob184(structIterations, A);
}
extern uint64_t rob185(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob185(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob185(structIterations, A);
}
extern uint64_t rob186(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob186(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob186(structIterations, A);
}
extern uint64_t rob187(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob187(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob187(structIterations, A);
}
extern uint64_t rob188(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob188(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob188(structIterations, A);
}
extern uint64_t rob189(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob189(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob189(structIterations, A);
}
extern uint64_t rob190(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob190(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob190(structIterations, A);
}
extern uint64_t rob191(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob191(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob191(structIterations, A);
}
extern uint64_t rob192(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob192(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob192(structIterations, A);
}
extern uint64_t rob193(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob193(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob193(structIterations, A);
}
extern uint64_t rob194(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob194(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob194(structIterations, A);
}
extern uint64_t rob195(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob195(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob195(structIterations, A);
}
extern uint64_t rob196(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob196(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob196(structIterations, A);
}
extern uint64_t rob197(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob197(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob197(structIterations, A);
}
extern uint64_t rob198(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob198(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob198(structIterations, A);
}
extern uint64_t rob199(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob199(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob199(structIterations, A);
}
extern uint64_t rob200(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob200(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob200(structIterations, A);
}
extern uint64_t rob201(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob201(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob201(structIterations, A);
}
extern uint64_t rob202(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob202(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob202(structIterations, A);
}
extern uint64_t rob203(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob203(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob203(structIterations, A);
}
extern uint64_t rob204(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob204(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob204(structIterations, A);
}
extern uint64_t rob205(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob205(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob205(structIterations, A);
}
extern uint64_t rob206(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob206(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob206(structIterations, A);
}
extern uint64_t rob207(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob207(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob207(structIterations, A);
}
extern uint64_t rob208(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob208(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob208(structIterations, A);
}
extern uint64_t rob209(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob209(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob209(structIterations, A);
}
extern uint64_t rob210(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob210(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob210(structIterations, A);
}
extern uint64_t rob211(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob211(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob211(structIterations, A);
}
extern uint64_t rob212(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob212(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob212(structIterations, A);
}
extern uint64_t rob213(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob213(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob213(structIterations, A);
}
extern uint64_t rob214(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob214(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob214(structIterations, A);
}
extern uint64_t rob215(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob215(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob215(structIterations, A);
}
extern uint64_t rob216(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob216(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob216(structIterations, A);
}
extern uint64_t rob217(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob217(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob217(structIterations, A);
}
extern uint64_t rob218(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob218(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob218(structIterations, A);
}
extern uint64_t rob219(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob219(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob219(structIterations, A);
}
extern uint64_t rob220(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob220(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob220(structIterations, A);
}
extern uint64_t rob221(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob221(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob221(structIterations, A);
}
extern uint64_t rob222(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob222(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob222(structIterations, A);
}
extern uint64_t rob223(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob223(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob223(structIterations, A);
}
extern uint64_t rob224(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob224(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob224(structIterations, A);
}
extern uint64_t rob225(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob225(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob225(structIterations, A);
}
extern uint64_t rob226(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob226(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob226(structIterations, A);
}
extern uint64_t rob227(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob227(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob227(structIterations, A);
}
extern uint64_t rob228(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob228(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob228(structIterations, A);
}
extern uint64_t rob229(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob229(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob229(structIterations, A);
}
extern uint64_t rob230(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob230(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob230(structIterations, A);
}
extern uint64_t rob231(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob231(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob231(structIterations, A);
}
extern uint64_t rob232(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob232(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob232(structIterations, A);
}
extern uint64_t rob233(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob233(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob233(structIterations, A);
}
extern uint64_t rob234(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob234(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob234(structIterations, A);
}
extern uint64_t rob235(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob235(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob235(structIterations, A);
}
extern uint64_t rob236(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob236(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob236(structIterations, A);
}
extern uint64_t rob237(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob237(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob237(structIterations, A);
}
extern uint64_t rob238(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob238(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob238(structIterations, A);
}
extern uint64_t rob239(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob239(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob239(structIterations, A);
}
extern uint64_t rob240(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob240(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob240(structIterations, A);
}
extern uint64_t rob241(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob241(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob241(structIterations, A);
}
extern uint64_t rob242(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob242(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob242(structIterations, A);
}
extern uint64_t rob243(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob243(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob243(structIterations, A);
}
extern uint64_t rob244(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob244(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob244(structIterations, A);
}
extern uint64_t rob245(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob245(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob245(structIterations, A);
}
extern uint64_t rob246(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob246(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob246(structIterations, A);
}
extern uint64_t rob247(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob247(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob247(structIterations, A);
}
extern uint64_t rob248(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob248(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob248(structIterations, A);
}
extern uint64_t rob249(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob249(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob249(structIterations, A);
}
extern uint64_t rob250(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob250(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob250(structIterations, A);
}
extern uint64_t rob251(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob251(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob251(structIterations, A);
}
extern uint64_t rob252(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob252(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob252(structIterations, A);
}
extern uint64_t rob253(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob253(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob253(structIterations, A);
}
extern uint64_t rob254(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob254(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob254(structIterations, A);
}
extern uint64_t rob255(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob255(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob255(structIterations, A);
}
extern uint64_t rob256(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob256(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob256(structIterations, A);
}
extern uint64_t rob257(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob257(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob257(structIterations, A);
}
extern uint64_t rob258(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob258(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob258(structIterations, A);
}
extern uint64_t rob259(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob259(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob259(structIterations, A);
}
extern uint64_t rob260(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob260(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob260(structIterations, A);
}
extern uint64_t rob261(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob261(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob261(structIterations, A);
}
extern uint64_t rob262(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob262(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob262(structIterations, A);
}
extern uint64_t rob263(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob263(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob263(structIterations, A);
}
extern uint64_t rob264(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob264(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob264(structIterations, A);
}
extern uint64_t rob265(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob265(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob265(structIterations, A);
}
extern uint64_t rob266(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob266(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob266(structIterations, A);
}
extern uint64_t rob267(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob267(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob267(structIterations, A);
}
extern uint64_t rob268(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob268(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob268(structIterations, A);
}
extern uint64_t rob269(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob269(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob269(structIterations, A);
}
extern uint64_t rob270(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob270(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob270(structIterations, A);
}
extern uint64_t rob271(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob271(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob271(structIterations, A);
}
extern uint64_t rob272(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob272(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob272(structIterations, A);
}
extern uint64_t rob273(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob273(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob273(structIterations, A);
}
extern uint64_t rob274(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob274(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob274(structIterations, A);
}
extern uint64_t rob275(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob275(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob275(structIterations, A);
}
extern uint64_t rob276(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob276(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob276(structIterations, A);
}
extern uint64_t rob277(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob277(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob277(structIterations, A);
}
extern uint64_t rob278(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob278(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob278(structIterations, A);
}
extern uint64_t rob279(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob279(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob279(structIterations, A);
}
extern uint64_t rob280(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob280(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob280(structIterations, A);
}
extern uint64_t rob281(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob281(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob281(structIterations, A);
}
extern uint64_t rob282(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob282(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob282(structIterations, A);
}
extern uint64_t rob283(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob283(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob283(structIterations, A);
}
extern uint64_t rob284(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob284(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob284(structIterations, A);
}
extern uint64_t rob285(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob285(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob285(structIterations, A);
}
extern uint64_t rob286(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob286(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob286(structIterations, A);
}
extern uint64_t rob287(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob287(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob287(structIterations, A);
}
extern uint64_t rob288(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob288(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob288(structIterations, A);
}
extern uint64_t rob289(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob289(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob289(structIterations, A);
}
extern uint64_t rob290(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob290(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob290(structIterations, A);
}
extern uint64_t rob291(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob291(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob291(structIterations, A);
}
extern uint64_t rob292(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob292(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob292(structIterations, A);
}
extern uint64_t rob293(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob293(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob293(structIterations, A);
}
extern uint64_t rob294(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob294(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob294(structIterations, A);
}
extern uint64_t rob295(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob295(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob295(structIterations, A);
}
extern uint64_t rob296(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob296(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob296(structIterations, A);
}
extern uint64_t rob297(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob297(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob297(structIterations, A);
}
extern uint64_t rob298(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob298(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob298(structIterations, A);
}
extern uint64_t rob299(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob299(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob299(structIterations, A);
}
extern uint64_t rob300(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob300(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob300(structIterations, A);
}
extern uint64_t rob301(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob301(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob301(structIterations, A);
}
extern uint64_t rob302(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob302(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob302(structIterations, A);
}
extern uint64_t rob303(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob303(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob303(structIterations, A);
}
extern uint64_t rob304(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob304(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob304(structIterations, A);
}
extern uint64_t rob305(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob305(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob305(structIterations, A);
}
extern uint64_t rob306(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob306(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob306(structIterations, A);
}
extern uint64_t rob307(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob307(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob307(structIterations, A);
}
extern uint64_t rob308(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob308(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob308(structIterations, A);
}
extern uint64_t rob309(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob309(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob309(structIterations, A);
}
extern uint64_t rob310(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob310(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob310(structIterations, A);
}
extern uint64_t rob311(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob311(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob311(structIterations, A);
}
extern uint64_t rob312(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob312(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob312(structIterations, A);
}
extern uint64_t rob313(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob313(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob313(structIterations, A);
}
extern uint64_t rob314(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob314(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob314(structIterations, A);
}
extern uint64_t rob315(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob315(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob315(structIterations, A);
}
extern uint64_t rob316(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob316(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob316(structIterations, A);
}
extern uint64_t rob317(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob317(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob317(structIterations, A);
}
extern uint64_t rob318(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob318(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob318(structIterations, A);
}
extern uint64_t rob319(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob319(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob319(structIterations, A);
}
extern uint64_t rob320(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob320(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob320(structIterations, A);
}
extern uint64_t rob321(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob321(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob321(structIterations, A);
}
extern uint64_t rob322(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob322(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob322(structIterations, A);
}
extern uint64_t rob323(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob323(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob323(structIterations, A);
}
extern uint64_t rob324(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob324(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob324(structIterations, A);
}
extern uint64_t rob325(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob325(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob325(structIterations, A);
}
extern uint64_t rob326(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob326(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob326(structIterations, A);
}
extern uint64_t rob327(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob327(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob327(structIterations, A);
}
extern uint64_t rob328(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob328(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob328(structIterations, A);
}
extern uint64_t rob329(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob329(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob329(structIterations, A);
}
extern uint64_t rob330(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob330(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob330(structIterations, A);
}
extern uint64_t rob331(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob331(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob331(structIterations, A);
}
extern uint64_t rob332(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob332(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob332(structIterations, A);
}
extern uint64_t rob333(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob333(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob333(structIterations, A);
}
extern uint64_t rob334(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob334(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob334(structIterations, A);
}
extern uint64_t rob335(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob335(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob335(structIterations, A);
}
extern uint64_t rob336(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob336(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob336(structIterations, A);
}
extern uint64_t rob337(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob337(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob337(structIterations, A);
}
extern uint64_t rob338(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob338(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob338(structIterations, A);
}
extern uint64_t rob339(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob339(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob339(structIterations, A);
}
extern uint64_t rob340(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob340(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob340(structIterations, A);
}
extern uint64_t rob341(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob341(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob341(structIterations, A);
}
extern uint64_t rob342(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob342(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob342(structIterations, A);
}
extern uint64_t rob343(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob343(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob343(structIterations, A);
}
extern uint64_t rob344(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob344(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob344(structIterations, A);
}
extern uint64_t rob345(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob345(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob345(structIterations, A);
}
extern uint64_t rob346(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob346(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob346(structIterations, A);
}
extern uint64_t rob347(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob347(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob347(structIterations, A);
}
extern uint64_t rob348(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob348(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob348(structIterations, A);
}
extern uint64_t rob349(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob349(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob349(structIterations, A);
}
extern uint64_t rob350(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob350(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob350(structIterations, A);
}
extern uint64_t rob351(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob351(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob351(structIterations, A);
}
extern uint64_t rob352(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob352(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob352(structIterations, A);
}
extern uint64_t rob353(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob353(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob353(structIterations, A);
}
extern uint64_t rob354(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob354(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob354(structIterations, A);
}
extern uint64_t rob355(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob355(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob355(structIterations, A);
}
extern uint64_t rob356(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob356(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob356(structIterations, A);
}
extern uint64_t rob357(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob357(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob357(structIterations, A);
}
extern uint64_t rob358(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob358(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob358(structIterations, A);
}
extern uint64_t rob359(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob359(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob359(structIterations, A);
}
extern uint64_t rob360(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob360(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob360(structIterations, A);
}
extern uint64_t rob361(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob361(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob361(structIterations, A);
}
extern uint64_t rob362(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob362(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob362(structIterations, A);
}
extern uint64_t rob363(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob363(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob363(structIterations, A);
}
extern uint64_t rob364(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob364(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob364(structIterations, A);
}
extern uint64_t rob365(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob365(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob365(structIterations, A);
}
extern uint64_t rob366(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob366(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob366(structIterations, A);
}
extern uint64_t rob367(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob367(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob367(structIterations, A);
}
extern uint64_t rob368(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob368(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob368(structIterations, A);
}
extern uint64_t rob369(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob369(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob369(structIterations, A);
}
extern uint64_t rob370(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob370(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob370(structIterations, A);
}
extern uint64_t rob371(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob371(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob371(structIterations, A);
}
extern uint64_t rob372(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob372(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob372(structIterations, A);
}
extern uint64_t rob373(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob373(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob373(structIterations, A);
}
extern uint64_t rob374(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob374(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob374(structIterations, A);
}
extern uint64_t rob375(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob375(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob375(structIterations, A);
}
extern uint64_t rob376(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob376(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob376(structIterations, A);
}
extern uint64_t rob377(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob377(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob377(structIterations, A);
}
extern uint64_t rob378(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob378(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob378(structIterations, A);
}
extern uint64_t rob379(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob379(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob379(structIterations, A);
}
extern uint64_t rob380(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob380(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob380(structIterations, A);
}
extern uint64_t rob381(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob381(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob381(structIterations, A);
}
extern uint64_t rob382(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob382(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob382(structIterations, A);
}
extern uint64_t rob383(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob383(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob383(structIterations, A);
}
extern uint64_t rob384(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob384(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob384(structIterations, A);
}
extern uint64_t rob385(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob385(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob385(structIterations, A);
}
extern uint64_t rob386(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob386(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob386(structIterations, A);
}
extern uint64_t rob387(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob387(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob387(structIterations, A);
}
extern uint64_t rob388(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob388(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob388(structIterations, A);
}
extern uint64_t rob389(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob389(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob389(structIterations, A);
}
extern uint64_t rob390(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob390(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob390(structIterations, A);
}
extern uint64_t rob391(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob391(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob391(structIterations, A);
}
extern uint64_t rob392(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob392(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob392(structIterations, A);
}
extern uint64_t rob393(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob393(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob393(structIterations, A);
}
extern uint64_t rob394(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob394(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob394(structIterations, A);
}
extern uint64_t rob395(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob395(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob395(structIterations, A);
}
extern uint64_t rob396(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob396(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob396(structIterations, A);
}
extern uint64_t rob397(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob397(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob397(structIterations, A);
}
extern uint64_t rob398(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob398(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob398(structIterations, A);
}
extern uint64_t rob399(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob399(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob399(structIterations, A);
}
extern uint64_t rob400(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob400(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob400(structIterations, A);
}
extern uint64_t rob401(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob401(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob401(structIterations, A);
}
extern uint64_t rob402(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob402(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob402(structIterations, A);
}
extern uint64_t rob403(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob403(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob403(structIterations, A);
}
extern uint64_t rob404(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob404(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob404(structIterations, A);
}
extern uint64_t rob405(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob405(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob405(structIterations, A);
}
extern uint64_t rob406(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob406(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob406(structIterations, A);
}
extern uint64_t rob407(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob407(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob407(structIterations, A);
}
extern uint64_t rob408(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob408(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob408(structIterations, A);
}
extern uint64_t rob409(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob409(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob409(structIterations, A);
}
extern uint64_t rob410(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob410(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob410(structIterations, A);
}
extern uint64_t rob411(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob411(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob411(structIterations, A);
}
extern uint64_t rob412(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob412(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob412(structIterations, A);
}
extern uint64_t rob413(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob413(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob413(structIterations, A);
}
extern uint64_t rob414(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob414(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob414(structIterations, A);
}
extern uint64_t rob415(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob415(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob415(structIterations, A);
}
extern uint64_t rob416(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob416(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob416(structIterations, A);
}
extern uint64_t rob417(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob417(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob417(structIterations, A);
}
extern uint64_t rob418(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob418(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob418(structIterations, A);
}
extern uint64_t rob419(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob419(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob419(structIterations, A);
}
extern uint64_t rob420(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob420(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob420(structIterations, A);
}
extern uint64_t rob421(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob421(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob421(structIterations, A);
}
extern uint64_t rob422(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob422(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob422(structIterations, A);
}
extern uint64_t rob423(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob423(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob423(structIterations, A);
}
extern uint64_t rob424(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob424(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob424(structIterations, A);
}
extern uint64_t rob425(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob425(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob425(structIterations, A);
}
extern uint64_t rob426(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob426(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob426(structIterations, A);
}
extern uint64_t rob427(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob427(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob427(structIterations, A);
}
extern uint64_t rob428(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob428(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob428(structIterations, A);
}
extern uint64_t rob429(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob429(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob429(structIterations, A);
}
extern uint64_t rob430(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob430(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob430(structIterations, A);
}
extern uint64_t rob431(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob431(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob431(structIterations, A);
}
extern uint64_t rob432(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob432(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob432(structIterations, A);
}
extern uint64_t rob433(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob433(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob433(structIterations, A);
}
extern uint64_t rob434(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob434(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob434(structIterations, A);
}
extern uint64_t rob435(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob435(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob435(structIterations, A);
}
extern uint64_t rob436(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob436(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob436(structIterations, A);
}
extern uint64_t rob437(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob437(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob437(structIterations, A);
}
extern uint64_t rob438(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob438(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob438(structIterations, A);
}
extern uint64_t rob439(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob439(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob439(structIterations, A);
}
extern uint64_t rob440(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob440(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob440(structIterations, A);
}
extern uint64_t rob441(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob441(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob441(structIterations, A);
}
extern uint64_t rob442(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob442(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob442(structIterations, A);
}
extern uint64_t rob443(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob443(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob443(structIterations, A);
}
extern uint64_t rob444(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob444(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob444(structIterations, A);
}
extern uint64_t rob445(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob445(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob445(structIterations, A);
}
extern uint64_t rob446(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob446(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob446(structIterations, A);
}
extern uint64_t rob447(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob447(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob447(structIterations, A);
}
extern uint64_t rob448(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob448(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob448(structIterations, A);
}
extern uint64_t rob449(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob449(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob449(structIterations, A);
}
extern uint64_t rob450(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob450(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob450(structIterations, A);
}
extern uint64_t rob451(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob451(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob451(structIterations, A);
}
extern uint64_t rob452(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob452(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob452(structIterations, A);
}
extern uint64_t rob453(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob453(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob453(structIterations, A);
}
extern uint64_t rob454(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob454(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob454(structIterations, A);
}
extern uint64_t rob455(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob455(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob455(structIterations, A);
}
extern uint64_t rob456(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob456(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob456(structIterations, A);
}
extern uint64_t rob457(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob457(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob457(structIterations, A);
}
extern uint64_t rob458(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob458(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob458(structIterations, A);
}
extern uint64_t rob459(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob459(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob459(structIterations, A);
}
extern uint64_t rob460(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob460(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob460(structIterations, A);
}
extern uint64_t rob461(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob461(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob461(structIterations, A);
}
extern uint64_t rob462(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob462(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob462(structIterations, A);
}
extern uint64_t rob463(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob463(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob463(structIterations, A);
}
extern uint64_t rob464(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob464(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob464(structIterations, A);
}
extern uint64_t rob465(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob465(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob465(structIterations, A);
}
extern uint64_t rob466(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob466(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob466(structIterations, A);
}
extern uint64_t rob467(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob467(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob467(structIterations, A);
}
extern uint64_t rob468(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob468(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob468(structIterations, A);
}
extern uint64_t rob469(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob469(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob469(structIterations, A);
}
extern uint64_t rob470(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob470(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob470(structIterations, A);
}
extern uint64_t rob471(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob471(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob471(structIterations, A);
}
extern uint64_t rob472(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob472(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob472(structIterations, A);
}
extern uint64_t rob473(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob473(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob473(structIterations, A);
}
extern uint64_t rob474(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob474(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob474(structIterations, A);
}
extern uint64_t rob475(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob475(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob475(structIterations, A);
}
extern uint64_t rob476(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob476(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob476(structIterations, A);
}
extern uint64_t rob477(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob477(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob477(structIterations, A);
}
extern uint64_t rob478(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob478(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob478(structIterations, A);
}
extern uint64_t rob479(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob479(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob479(structIterations, A);
}
extern uint64_t rob480(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob480(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob480(structIterations, A);
}
extern uint64_t rob481(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob481(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob481(structIterations, A);
}
extern uint64_t rob482(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob482(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob482(structIterations, A);
}
extern uint64_t rob483(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob483(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob483(structIterations, A);
}
extern uint64_t rob484(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob484(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob484(structIterations, A);
}
extern uint64_t rob485(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob485(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob485(structIterations, A);
}
extern uint64_t rob486(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob486(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob486(structIterations, A);
}
extern uint64_t rob487(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob487(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob487(structIterations, A);
}
extern uint64_t rob488(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob488(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob488(structIterations, A);
}
extern uint64_t rob489(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob489(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob489(structIterations, A);
}
extern uint64_t rob490(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob490(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob490(structIterations, A);
}
extern uint64_t rob491(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob491(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob491(structIterations, A);
}
extern uint64_t rob492(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob492(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob492(structIterations, A);
}
extern uint64_t rob493(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob493(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob493(structIterations, A);
}
extern uint64_t rob494(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob494(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob494(structIterations, A);
}
extern uint64_t rob495(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob495(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob495(structIterations, A);
}
extern uint64_t rob496(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob496(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob496(structIterations, A);
}
extern uint64_t rob497(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob497(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob497(structIterations, A);
}
extern uint64_t rob498(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob498(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob498(structIterations, A);
}
extern uint64_t rob499(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob499(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob499(structIterations, A);
}
extern uint64_t rob500(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob500(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob500(structIterations, A);
}
extern uint64_t rob501(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob501(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob501(structIterations, A);
}
extern uint64_t rob502(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob502(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob502(structIterations, A);
}
extern uint64_t rob503(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob503(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob503(structIterations, A);
}
extern uint64_t rob504(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob504(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob504(structIterations, A);
}
extern uint64_t rob505(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob505(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob505(structIterations, A);
}
extern uint64_t rob506(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob506(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob506(structIterations, A);
}
extern uint64_t rob507(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob507(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob507(structIterations, A);
}
extern uint64_t rob508(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob508(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob508(structIterations, A);
}
extern uint64_t rob509(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob509(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob509(structIterations, A);
}
extern uint64_t rob510(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob510(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob510(structIterations, A);
}
extern uint64_t rob511(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob511(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob511(structIterations, A);
}
extern uint64_t rob512(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob512(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob512(structIterations, A);
}
extern uint64_t rob513(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob513(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob513(structIterations, A);
}
extern uint64_t rob514(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob514(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob514(structIterations, A);
}
extern uint64_t rob515(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob515(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob515(structIterations, A);
}
extern uint64_t rob516(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob516(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob516(structIterations, A);
}
extern uint64_t rob517(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob517(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob517(structIterations, A);
}
extern uint64_t rob518(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob518(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob518(structIterations, A);
}
extern uint64_t rob519(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob519(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob519(structIterations, A);
}
extern uint64_t rob520(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob520(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob520(structIterations, A);
}
extern uint64_t rob521(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob521(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob521(structIterations, A);
}
extern uint64_t rob522(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob522(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob522(structIterations, A);
}
extern uint64_t rob523(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob523(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob523(structIterations, A);
}
extern uint64_t rob524(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob524(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob524(structIterations, A);
}
extern uint64_t rob525(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob525(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob525(structIterations, A);
}
extern uint64_t rob526(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob526(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob526(structIterations, A);
}
extern uint64_t rob527(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob527(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob527(structIterations, A);
}
extern uint64_t rob528(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob528(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob528(structIterations, A);
}
extern uint64_t rob529(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob529(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob529(structIterations, A);
}
extern uint64_t rob530(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob530(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob530(structIterations, A);
}
extern uint64_t rob531(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob531(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob531(structIterations, A);
}
extern uint64_t rob532(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob532(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob532(structIterations, A);
}
extern uint64_t rob533(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob533(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob533(structIterations, A);
}
extern uint64_t rob534(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob534(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob534(structIterations, A);
}
extern uint64_t rob535(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob535(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob535(structIterations, A);
}
extern uint64_t rob536(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob536(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob536(structIterations, A);
}
extern uint64_t rob537(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob537(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob537(structIterations, A);
}
extern uint64_t rob538(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob538(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob538(structIterations, A);
}
extern uint64_t rob539(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob539(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob539(structIterations, A);
}
extern uint64_t rob540(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob540(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob540(structIterations, A);
}
extern uint64_t rob541(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob541(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob541(structIterations, A);
}
extern uint64_t rob542(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob542(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob542(structIterations, A);
}
extern uint64_t rob543(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob543(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob543(structIterations, A);
}
extern uint64_t rob544(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob544(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob544(structIterations, A);
}
extern uint64_t rob545(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob545(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob545(structIterations, A);
}
extern uint64_t rob546(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob546(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob546(structIterations, A);
}
extern uint64_t rob547(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob547(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob547(structIterations, A);
}
extern uint64_t rob548(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob548(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob548(structIterations, A);
}
extern uint64_t rob549(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob549(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob549(structIterations, A);
}
extern uint64_t rob550(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob550(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob550(structIterations, A);
}
extern uint64_t rob551(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob551(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob551(structIterations, A);
}
extern uint64_t rob552(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob552(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob552(structIterations, A);
}
extern uint64_t rob553(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob553(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob553(structIterations, A);
}
extern uint64_t rob554(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob554(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob554(structIterations, A);
}
extern uint64_t rob555(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob555(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob555(structIterations, A);
}
extern uint64_t rob556(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob556(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob556(structIterations, A);
}
extern uint64_t rob557(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob557(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob557(structIterations, A);
}
extern uint64_t rob558(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob558(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob558(structIterations, A);
}
extern uint64_t rob559(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob559(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob559(structIterations, A);
}
extern uint64_t rob560(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob560(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob560(structIterations, A);
}
extern uint64_t rob561(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob561(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob561(structIterations, A);
}
extern uint64_t rob562(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob562(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob562(structIterations, A);
}
extern uint64_t rob563(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob563(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob563(structIterations, A);
}
extern uint64_t rob564(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob564(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob564(structIterations, A);
}
extern uint64_t rob565(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob565(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob565(structIterations, A);
}
extern uint64_t rob566(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob566(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob566(structIterations, A);
}
extern uint64_t rob567(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob567(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob567(structIterations, A);
}
extern uint64_t rob568(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob568(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob568(structIterations, A);
}
extern uint64_t rob569(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob569(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob569(structIterations, A);
}
extern uint64_t rob570(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob570(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob570(structIterations, A);
}
extern uint64_t rob571(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob571(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob571(structIterations, A);
}
extern uint64_t rob572(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob572(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob572(structIterations, A);
}
extern uint64_t rob573(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob573(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob573(structIterations, A);
}
extern uint64_t rob574(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob574(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob574(structIterations, A);
}
extern uint64_t rob575(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob575(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob575(structIterations, A);
}
extern uint64_t rob576(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob576(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob576(structIterations, A);
}
extern uint64_t rob577(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob577(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob577(structIterations, A);
}
extern uint64_t rob578(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob578(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob578(structIterations, A);
}
extern uint64_t rob579(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob579(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob579(structIterations, A);
}
extern uint64_t rob580(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob580(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob580(structIterations, A);
}
extern uint64_t rob581(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob581(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob581(structIterations, A);
}
extern uint64_t rob582(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob582(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob582(structIterations, A);
}
extern uint64_t rob583(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob583(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob583(structIterations, A);
}
extern uint64_t rob584(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob584(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob584(structIterations, A);
}
extern uint64_t rob585(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob585(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob585(structIterations, A);
}
extern uint64_t rob586(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob586(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob586(structIterations, A);
}
extern uint64_t rob587(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob587(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob587(structIterations, A);
}
extern uint64_t rob588(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob588(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob588(structIterations, A);
}
extern uint64_t rob589(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob589(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob589(structIterations, A);
}
extern uint64_t rob590(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob590(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob590(structIterations, A);
}
extern uint64_t rob591(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob591(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob591(structIterations, A);
}
extern uint64_t rob592(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob592(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob592(structIterations, A);
}
extern uint64_t rob593(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob593(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob593(structIterations, A);
}
extern uint64_t rob594(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob594(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob594(structIterations, A);
}
extern uint64_t rob595(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob595(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob595(structIterations, A);
}
extern uint64_t rob596(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob596(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob596(structIterations, A);
}
extern uint64_t rob597(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob597(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob597(structIterations, A);
}
extern uint64_t rob598(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob598(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob598(structIterations, A);
}
extern uint64_t rob599(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob599(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob599(structIterations, A);
}
extern uint64_t rob600(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob600(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob600(structIterations, A);
}
extern uint64_t rob601(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob601(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob601(structIterations, A);
}
extern uint64_t rob602(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob602(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob602(structIterations, A);
}
extern uint64_t rob603(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob603(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob603(structIterations, A);
}
extern uint64_t rob604(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob604(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob604(structIterations, A);
}
extern uint64_t rob605(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob605(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob605(structIterations, A);
}
extern uint64_t rob606(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob606(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob606(structIterations, A);
}
extern uint64_t rob607(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob607(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob607(structIterations, A);
}
extern uint64_t rob608(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob608(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob608(structIterations, A);
}
extern uint64_t rob609(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob609(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob609(structIterations, A);
}
extern uint64_t rob610(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob610(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob610(structIterations, A);
}
extern uint64_t rob611(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob611(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob611(structIterations, A);
}
extern uint64_t rob612(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob612(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob612(structIterations, A);
}
extern uint64_t rob613(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob613(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob613(structIterations, A);
}
extern uint64_t rob614(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob614(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob614(structIterations, A);
}
extern uint64_t rob615(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob615(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob615(structIterations, A);
}
extern uint64_t rob616(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob616(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob616(structIterations, A);
}
extern uint64_t rob617(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob617(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob617(structIterations, A);
}
extern uint64_t rob618(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob618(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob618(structIterations, A);
}
extern uint64_t rob619(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob619(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob619(structIterations, A);
}
extern uint64_t rob620(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob620(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob620(structIterations, A);
}
extern uint64_t rob621(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob621(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob621(structIterations, A);
}
extern uint64_t rob622(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob622(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob622(structIterations, A);
}
extern uint64_t rob623(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob623(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob623(structIterations, A);
}
extern uint64_t rob624(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob624(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob624(structIterations, A);
}
extern uint64_t rob625(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob625(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob625(structIterations, A);
}
extern uint64_t rob626(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob626(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob626(structIterations, A);
}
extern uint64_t rob627(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob627(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob627(structIterations, A);
}
extern uint64_t rob628(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob628(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob628(structIterations, A);
}
extern uint64_t rob629(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob629(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob629(structIterations, A);
}
extern uint64_t rob630(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob630(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob630(structIterations, A);
}
extern uint64_t rob631(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob631(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob631(structIterations, A);
}
extern uint64_t rob632(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob632(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob632(structIterations, A);
}
extern uint64_t rob633(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob633(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob633(structIterations, A);
}
extern uint64_t rob634(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob634(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob634(structIterations, A);
}
extern uint64_t rob635(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob635(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob635(structIterations, A);
}
extern uint64_t rob636(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob636(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob636(structIterations, A);
}
extern uint64_t rob637(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob637(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob637(structIterations, A);
}
extern uint64_t rob638(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob638(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob638(structIterations, A);
}
extern uint64_t rob639(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob639(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob639(structIterations, A);
}
extern uint64_t rob640(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob640(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob640(structIterations, A);
}
extern uint64_t rob641(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob641(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob641(structIterations, A);
}
extern uint64_t rob642(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob642(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob642(structIterations, A);
}
extern uint64_t rob643(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob643(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob643(structIterations, A);
}
extern uint64_t rob644(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob644(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob644(structIterations, A);
}
extern uint64_t rob645(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob645(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob645(structIterations, A);
}
extern uint64_t rob646(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob646(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob646(structIterations, A);
}
extern uint64_t rob647(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob647(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob647(structIterations, A);
}
extern uint64_t rob648(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob648(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob648(structIterations, A);
}
extern uint64_t rob649(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob649(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob649(structIterations, A);
}
extern uint64_t rob650(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob650(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob650(structIterations, A);
}
extern uint64_t rob651(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob651(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob651(structIterations, A);
}
extern uint64_t rob652(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob652(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob652(structIterations, A);
}
extern uint64_t rob653(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob653(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob653(structIterations, A);
}
extern uint64_t rob654(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob654(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob654(structIterations, A);
}
extern uint64_t rob655(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob655(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob655(structIterations, A);
}
extern uint64_t rob656(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob656(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob656(structIterations, A);
}
extern uint64_t rob657(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob657(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob657(structIterations, A);
}
extern uint64_t rob658(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob658(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob658(structIterations, A);
}
extern uint64_t rob659(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob659(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob659(structIterations, A);
}
extern uint64_t rob660(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob660(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob660(structIterations, A);
}
extern uint64_t rob661(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob661(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob661(structIterations, A);
}
extern uint64_t rob662(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob662(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob662(structIterations, A);
}
extern uint64_t rob663(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob663(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob663(structIterations, A);
}
extern uint64_t rob664(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob664(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob664(structIterations, A);
}
extern uint64_t rob665(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob665(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob665(structIterations, A);
}
extern uint64_t rob666(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob666(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob666(structIterations, A);
}
extern uint64_t rob667(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob667(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob667(structIterations, A);
}
extern uint64_t rob668(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob668(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob668(structIterations, A);
}
extern uint64_t rob669(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob669(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob669(structIterations, A);
}
extern uint64_t rob670(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob670(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob670(structIterations, A);
}
extern uint64_t rob671(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob671(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob671(structIterations, A);
}
extern uint64_t rob672(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob672(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob672(structIterations, A);
}
extern uint64_t rob673(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob673(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob673(structIterations, A);
}
extern uint64_t rob674(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob674(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob674(structIterations, A);
}
extern uint64_t rob675(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob675(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob675(structIterations, A);
}
extern uint64_t rob676(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob676(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob676(structIterations, A);
}
extern uint64_t rob677(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob677(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob677(structIterations, A);
}
extern uint64_t rob678(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob678(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob678(structIterations, A);
}
extern uint64_t rob679(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob679(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob679(structIterations, A);
}
extern uint64_t rob680(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob680(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob680(structIterations, A);
}
extern uint64_t rob681(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob681(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob681(structIterations, A);
}
extern uint64_t rob682(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob682(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob682(structIterations, A);
}
extern uint64_t rob683(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob683(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob683(structIterations, A);
}
extern uint64_t rob684(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob684(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob684(structIterations, A);
}
extern uint64_t rob685(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob685(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob685(structIterations, A);
}
extern uint64_t rob686(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob686(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob686(structIterations, A);
}
extern uint64_t rob687(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob687(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob687(structIterations, A);
}
extern uint64_t rob688(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob688(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob688(structIterations, A);
}
extern uint64_t rob689(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob689(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob689(structIterations, A);
}
extern uint64_t rob690(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob690(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob690(structIterations, A);
}
extern uint64_t rob691(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob691(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob691(structIterations, A);
}
extern uint64_t rob692(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob692(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob692(structIterations, A);
}
extern uint64_t rob693(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob693(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob693(structIterations, A);
}
extern uint64_t rob694(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob694(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob694(structIterations, A);
}
extern uint64_t rob695(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob695(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob695(structIterations, A);
}
extern uint64_t rob696(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob696(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob696(structIterations, A);
}
extern uint64_t rob697(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob697(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob697(structIterations, A);
}
extern uint64_t rob698(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob698(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob698(structIterations, A);
}
extern uint64_t rob699(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob699(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob699(structIterations, A);
}
extern uint64_t rob700(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob700(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob700(structIterations, A);
}
extern uint64_t rob701(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob701(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob701(structIterations, A);
}
extern uint64_t rob702(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob702(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob702(structIterations, A);
}
extern uint64_t rob703(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob703(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob703(structIterations, A);
}
extern uint64_t rob704(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob704(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob704(structIterations, A);
}
extern uint64_t rob705(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob705(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob705(structIterations, A);
}
extern uint64_t rob706(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob706(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob706(structIterations, A);
}
extern uint64_t rob707(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob707(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob707(structIterations, A);
}
extern uint64_t rob708(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob708(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob708(structIterations, A);
}
extern uint64_t rob709(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob709(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob709(structIterations, A);
}
extern uint64_t rob710(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob710(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob710(structIterations, A);
}
extern uint64_t rob711(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob711(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob711(structIterations, A);
}
extern uint64_t rob712(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob712(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob712(structIterations, A);
}
extern uint64_t rob713(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob713(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob713(structIterations, A);
}
extern uint64_t rob714(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob714(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob714(structIterations, A);
}
extern uint64_t rob715(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob715(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob715(structIterations, A);
}
extern uint64_t rob716(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob716(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob716(structIterations, A);
}
extern uint64_t rob717(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob717(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob717(structIterations, A);
}
extern uint64_t rob718(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob718(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob718(structIterations, A);
}
extern uint64_t rob719(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob719(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob719(structIterations, A);
}
extern uint64_t rob720(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob720(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob720(structIterations, A);
}
extern uint64_t rob721(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob721(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob721(structIterations, A);
}
extern uint64_t rob722(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob722(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob722(structIterations, A);
}
extern uint64_t rob723(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob723(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob723(structIterations, A);
}
extern uint64_t rob724(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob724(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob724(structIterations, A);
}
extern uint64_t rob725(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob725(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob725(structIterations, A);
}
extern uint64_t rob726(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob726(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob726(structIterations, A);
}
extern uint64_t rob727(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob727(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob727(structIterations, A);
}
extern uint64_t rob728(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob728(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob728(structIterations, A);
}
extern uint64_t rob729(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob729(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob729(structIterations, A);
}
extern uint64_t rob730(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob730(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob730(structIterations, A);
}
extern uint64_t rob731(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob731(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob731(structIterations, A);
}
extern uint64_t rob732(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob732(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob732(structIterations, A);
}
extern uint64_t rob733(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob733(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob733(structIterations, A);
}
extern uint64_t rob734(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob734(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob734(structIterations, A);
}
extern uint64_t rob735(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob735(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob735(structIterations, A);
}
extern uint64_t rob736(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob736(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob736(structIterations, A);
}
extern uint64_t rob737(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob737(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob737(structIterations, A);
}
extern uint64_t rob738(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob738(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob738(structIterations, A);
}
extern uint64_t rob739(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob739(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob739(structIterations, A);
}
extern uint64_t rob740(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob740(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob740(structIterations, A);
}
extern uint64_t rob741(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob741(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob741(structIterations, A);
}
extern uint64_t rob742(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob742(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob742(structIterations, A);
}
extern uint64_t rob743(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob743(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob743(structIterations, A);
}
extern uint64_t rob744(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob744(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob744(structIterations, A);
}
extern uint64_t rob745(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob745(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob745(structIterations, A);
}
extern uint64_t rob746(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob746(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob746(structIterations, A);
}
extern uint64_t rob747(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob747(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob747(structIterations, A);
}
extern uint64_t rob748(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob748(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob748(structIterations, A);
}
extern uint64_t rob749(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob749(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob749(structIterations, A);
}
extern uint64_t rob750(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob750(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob750(structIterations, A);
}
extern uint64_t rob751(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob751(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob751(structIterations, A);
}
extern uint64_t rob752(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob752(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob752(structIterations, A);
}
extern uint64_t rob753(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob753(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob753(structIterations, A);
}
extern uint64_t rob754(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob754(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob754(structIterations, A);
}
extern uint64_t rob755(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob755(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob755(structIterations, A);
}
extern uint64_t rob756(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob756(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob756(structIterations, A);
}
extern uint64_t rob757(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob757(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob757(structIterations, A);
}
extern uint64_t rob758(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob758(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob758(structIterations, A);
}
extern uint64_t rob759(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob759(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob759(structIterations, A);
}
extern uint64_t rob760(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob760(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob760(structIterations, A);
}
extern uint64_t rob761(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob761(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob761(structIterations, A);
}
extern uint64_t rob762(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob762(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob762(structIterations, A);
}
extern uint64_t rob763(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob763(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob763(structIterations, A);
}
extern uint64_t rob764(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob764(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob764(structIterations, A);
}
extern uint64_t rob765(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob765(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob765(structIterations, A);
}
extern uint64_t rob766(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob766(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob766(structIterations, A);
}
extern uint64_t rob767(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob767(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob767(structIterations, A);
}
extern uint64_t rob768(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob768(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob768(structIterations, A);
}
extern uint64_t rob769(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob769(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob769(structIterations, A);
}
extern uint64_t rob770(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob770(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob770(structIterations, A);
}
extern uint64_t rob771(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob771(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob771(structIterations, A);
}
extern uint64_t rob772(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob772(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob772(structIterations, A);
}
extern uint64_t rob773(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob773(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob773(structIterations, A);
}
extern uint64_t rob774(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob774(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob774(structIterations, A);
}
extern uint64_t rob775(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob775(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob775(structIterations, A);
}
extern uint64_t rob776(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob776(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob776(structIterations, A);
}
extern uint64_t rob777(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob777(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob777(structIterations, A);
}
extern uint64_t rob778(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob778(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob778(structIterations, A);
}
extern uint64_t rob779(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob779(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob779(structIterations, A);
}
extern uint64_t rob780(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob780(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob780(structIterations, A);
}
extern uint64_t rob781(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob781(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob781(structIterations, A);
}
extern uint64_t rob782(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob782(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob782(structIterations, A);
}
extern uint64_t rob783(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob783(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob783(structIterations, A);
}
extern uint64_t rob784(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob784(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob784(structIterations, A);
}
extern uint64_t rob785(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob785(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob785(structIterations, A);
}
extern uint64_t rob786(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob786(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob786(structIterations, A);
}
extern uint64_t rob787(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob787(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob787(structIterations, A);
}
extern uint64_t rob788(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob788(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob788(structIterations, A);
}
extern uint64_t rob789(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob789(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob789(structIterations, A);
}
extern uint64_t rob790(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob790(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob790(structIterations, A);
}
extern uint64_t rob791(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob791(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob791(structIterations, A);
}
extern uint64_t rob792(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob792(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob792(structIterations, A);
}
extern uint64_t rob793(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob793(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob793(structIterations, A);
}
extern uint64_t rob794(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob794(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob794(structIterations, A);
}
extern uint64_t rob795(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob795(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob795(structIterations, A);
}
extern uint64_t rob796(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob796(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob796(structIterations, A);
}
extern uint64_t rob797(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob797(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob797(structIterations, A);
}
extern uint64_t rob798(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob798(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob798(structIterations, A);
}
extern uint64_t rob799(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob799(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob799(structIterations, A);
}
extern uint64_t rob800(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob800(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob800(structIterations, A);
}
extern uint64_t rob801(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob801(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob801(structIterations, A);
}
extern uint64_t rob802(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob802(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob802(structIterations, A);
}
extern uint64_t rob803(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob803(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob803(structIterations, A);
}
extern uint64_t rob804(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob804(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob804(structIterations, A);
}
extern uint64_t rob805(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob805(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob805(structIterations, A);
}
extern uint64_t rob806(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob806(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob806(structIterations, A);
}
extern uint64_t rob807(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob807(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob807(structIterations, A);
}
extern uint64_t rob808(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob808(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob808(structIterations, A);
}
extern uint64_t rob809(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob809(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob809(structIterations, A);
}
extern uint64_t rob810(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob810(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob810(structIterations, A);
}
extern uint64_t rob811(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob811(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob811(structIterations, A);
}
extern uint64_t rob812(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob812(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob812(structIterations, A);
}
extern uint64_t rob813(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob813(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob813(structIterations, A);
}
extern uint64_t rob814(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob814(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob814(structIterations, A);
}
extern uint64_t rob815(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob815(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob815(structIterations, A);
}
extern uint64_t rob816(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob816(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob816(structIterations, A);
}
extern uint64_t rob817(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob817(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob817(structIterations, A);
}
extern uint64_t rob818(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob818(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob818(structIterations, A);
}
extern uint64_t rob819(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob819(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob819(structIterations, A);
}
extern uint64_t rob820(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob820(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob820(structIterations, A);
}
extern uint64_t rob821(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob821(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob821(structIterations, A);
}
extern uint64_t rob822(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob822(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob822(structIterations, A);
}
extern uint64_t rob823(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob823(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob823(structIterations, A);
}
extern uint64_t rob824(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob824(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob824(structIterations, A);
}
extern uint64_t rob825(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob825(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob825(structIterations, A);
}
extern uint64_t rob826(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob826(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob826(structIterations, A);
}
extern uint64_t rob827(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob827(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob827(structIterations, A);
}
extern uint64_t rob828(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob828(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob828(structIterations, A);
}
extern uint64_t rob829(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob829(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob829(structIterations, A);
}
extern uint64_t rob830(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob830(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob830(structIterations, A);
}
extern uint64_t rob831(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob831(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob831(structIterations, A);
}
extern uint64_t rob832(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob832(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob832(structIterations, A);
}
extern uint64_t rob833(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob833(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob833(structIterations, A);
}
extern uint64_t rob834(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob834(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob834(structIterations, A);
}
extern uint64_t rob835(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob835(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob835(structIterations, A);
}
extern uint64_t rob836(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob836(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob836(structIterations, A);
}
extern uint64_t rob837(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob837(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob837(structIterations, A);
}
extern uint64_t rob838(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob838(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob838(structIterations, A);
}
extern uint64_t rob839(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob839(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob839(structIterations, A);
}
extern uint64_t rob840(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob840(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob840(structIterations, A);
}
extern uint64_t rob841(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob841(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob841(structIterations, A);
}
extern uint64_t rob842(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob842(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob842(structIterations, A);
}
extern uint64_t rob843(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob843(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob843(structIterations, A);
}
extern uint64_t rob844(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob844(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob844(structIterations, A);
}
extern uint64_t rob845(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob845(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob845(structIterations, A);
}
extern uint64_t rob846(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob846(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob846(structIterations, A);
}
extern uint64_t rob847(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob847(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob847(structIterations, A);
}
extern uint64_t rob848(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob848(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob848(structIterations, A);
}
extern uint64_t rob849(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob849(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob849(structIterations, A);
}
extern uint64_t rob850(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob850(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob850(structIterations, A);
}
extern uint64_t rob851(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob851(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob851(structIterations, A);
}
extern uint64_t rob852(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob852(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob852(structIterations, A);
}
extern uint64_t rob853(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob853(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob853(structIterations, A);
}
extern uint64_t rob854(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob854(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob854(structIterations, A);
}
extern uint64_t rob855(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob855(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob855(structIterations, A);
}
extern uint64_t rob856(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob856(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob856(structIterations, A);
}
extern uint64_t rob857(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob857(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob857(structIterations, A);
}
extern uint64_t rob858(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob858(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob858(structIterations, A);
}
extern uint64_t rob859(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob859(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob859(structIterations, A);
}
extern uint64_t rob860(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob860(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob860(structIterations, A);
}
extern uint64_t rob861(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob861(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob861(structIterations, A);
}
extern uint64_t rob862(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob862(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob862(structIterations, A);
}
extern uint64_t rob863(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob863(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob863(structIterations, A);
}
extern uint64_t rob864(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob864(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob864(structIterations, A);
}
extern uint64_t rob865(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob865(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob865(structIterations, A);
}
extern uint64_t rob866(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob866(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob866(structIterations, A);
}
extern uint64_t rob867(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob867(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob867(structIterations, A);
}
extern uint64_t rob868(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob868(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob868(structIterations, A);
}
extern uint64_t rob869(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob869(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob869(structIterations, A);
}
extern uint64_t rob870(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob870(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob870(structIterations, A);
}
extern uint64_t rob871(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob871(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob871(structIterations, A);
}
extern uint64_t rob872(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob872(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob872(structIterations, A);
}
extern uint64_t rob873(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob873(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob873(structIterations, A);
}
extern uint64_t rob874(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob874(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob874(structIterations, A);
}
extern uint64_t rob875(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob875(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob875(structIterations, A);
}
extern uint64_t rob876(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob876(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob876(structIterations, A);
}
extern uint64_t rob877(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob877(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob877(structIterations, A);
}
extern uint64_t rob878(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob878(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob878(structIterations, A);
}
extern uint64_t rob879(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob879(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob879(structIterations, A);
}
extern uint64_t rob880(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob880(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob880(structIterations, A);
}
extern uint64_t rob881(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob881(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob881(structIterations, A);
}
extern uint64_t rob882(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob882(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob882(structIterations, A);
}
extern uint64_t rob883(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob883(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob883(structIterations, A);
}
extern uint64_t rob884(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob884(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob884(structIterations, A);
}
extern uint64_t rob885(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob885(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob885(structIterations, A);
}
extern uint64_t rob886(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob886(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob886(structIterations, A);
}
extern uint64_t rob887(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob887(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob887(structIterations, A);
}
extern uint64_t rob888(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob888(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob888(structIterations, A);
}
extern uint64_t rob889(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob889(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob889(structIterations, A);
}
extern uint64_t rob890(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob890(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob890(structIterations, A);
}
extern uint64_t rob891(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob891(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob891(structIterations, A);
}
extern uint64_t rob892(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob892(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob892(structIterations, A);
}
extern uint64_t rob893(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob893(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob893(structIterations, A);
}
extern uint64_t rob894(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob894(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob894(structIterations, A);
}
extern uint64_t rob895(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob895(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob895(structIterations, A);
}
extern uint64_t rob896(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob896(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob896(structIterations, A);
}
extern uint64_t rob897(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob897(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob897(structIterations, A);
}
extern uint64_t rob898(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob898(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob898(structIterations, A);
}
extern uint64_t rob899(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob899(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob899(structIterations, A);
}
extern uint64_t rob900(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob900(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob900(structIterations, A);
}
extern uint64_t rob901(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob901(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob901(structIterations, A);
}
extern uint64_t rob902(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob902(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob902(structIterations, A);
}
extern uint64_t rob903(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob903(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob903(structIterations, A);
}
extern uint64_t rob904(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob904(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob904(structIterations, A);
}
extern uint64_t rob905(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob905(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob905(structIterations, A);
}
extern uint64_t rob906(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob906(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob906(structIterations, A);
}
extern uint64_t rob907(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob907(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob907(structIterations, A);
}
extern uint64_t rob908(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob908(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob908(structIterations, A);
}
extern uint64_t rob909(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob909(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob909(structIterations, A);
}
extern uint64_t rob910(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob910(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob910(structIterations, A);
}
extern uint64_t rob911(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob911(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob911(structIterations, A);
}
extern uint64_t rob912(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob912(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob912(structIterations, A);
}
extern uint64_t rob913(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob913(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob913(structIterations, A);
}
extern uint64_t rob914(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob914(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob914(structIterations, A);
}
extern uint64_t rob915(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob915(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob915(structIterations, A);
}
extern uint64_t rob916(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob916(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob916(structIterations, A);
}
extern uint64_t rob917(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob917(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob917(structIterations, A);
}
extern uint64_t rob918(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob918(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob918(structIterations, A);
}
extern uint64_t rob919(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob919(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob919(structIterations, A);
}
extern uint64_t rob920(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob920(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob920(structIterations, A);
}
extern uint64_t rob921(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob921(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob921(structIterations, A);
}
extern uint64_t rob922(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob922(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob922(structIterations, A);
}
extern uint64_t rob923(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob923(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob923(structIterations, A);
}
extern uint64_t rob924(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob924(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob924(structIterations, A);
}
extern uint64_t rob925(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob925(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob925(structIterations, A);
}
extern uint64_t rob926(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob926(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob926(structIterations, A);
}
extern uint64_t rob927(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob927(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob927(structIterations, A);
}
extern uint64_t rob928(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob928(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob928(structIterations, A);
}
extern uint64_t rob929(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob929(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob929(structIterations, A);
}
extern uint64_t rob930(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob930(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob930(structIterations, A);
}
extern uint64_t rob931(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob931(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob931(structIterations, A);
}
extern uint64_t rob932(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob932(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob932(structIterations, A);
}
extern uint64_t rob933(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob933(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob933(structIterations, A);
}
extern uint64_t rob934(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob934(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob934(structIterations, A);
}
extern uint64_t rob935(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob935(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob935(structIterations, A);
}
extern uint64_t rob936(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob936(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob936(structIterations, A);
}
extern uint64_t rob937(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob937(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob937(structIterations, A);
}
extern uint64_t rob938(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob938(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob938(structIterations, A);
}
extern uint64_t rob939(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob939(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob939(structIterations, A);
}
extern uint64_t rob940(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob940(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob940(structIterations, A);
}
extern uint64_t rob941(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob941(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob941(structIterations, A);
}
extern uint64_t rob942(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob942(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob942(structIterations, A);
}
extern uint64_t rob943(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob943(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob943(structIterations, A);
}
extern uint64_t rob944(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob944(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob944(structIterations, A);
}
extern uint64_t rob945(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob945(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob945(structIterations, A);
}
extern uint64_t rob946(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob946(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob946(structIterations, A);
}
extern uint64_t rob947(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob947(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob947(structIterations, A);
}
extern uint64_t rob948(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob948(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob948(structIterations, A);
}
extern uint64_t rob949(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob949(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob949(structIterations, A);
}
extern uint64_t rob950(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob950(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob950(structIterations, A);
}
extern uint64_t rob951(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob951(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob951(structIterations, A);
}
extern uint64_t rob952(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob952(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob952(structIterations, A);
}
extern uint64_t rob953(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob953(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob953(structIterations, A);
}
extern uint64_t rob954(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob954(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob954(structIterations, A);
}
extern uint64_t rob955(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob955(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob955(structIterations, A);
}
extern uint64_t rob956(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob956(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob956(structIterations, A);
}
extern uint64_t rob957(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob957(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob957(structIterations, A);
}
extern uint64_t rob958(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob958(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob958(structIterations, A);
}
extern uint64_t rob959(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob959(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob959(structIterations, A);
}
extern uint64_t rob960(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob960(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob960(structIterations, A);
}
extern uint64_t rob961(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob961(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob961(structIterations, A);
}
extern uint64_t rob962(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob962(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob962(structIterations, A);
}
extern uint64_t rob963(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob963(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob963(structIterations, A);
}
extern uint64_t rob964(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob964(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob964(structIterations, A);
}
extern uint64_t rob965(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob965(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob965(structIterations, A);
}
extern uint64_t rob966(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob966(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob966(structIterations, A);
}
extern uint64_t rob967(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob967(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob967(structIterations, A);
}
extern uint64_t rob968(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob968(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob968(structIterations, A);
}
extern uint64_t rob969(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob969(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob969(structIterations, A);
}
extern uint64_t rob970(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob970(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob970(structIterations, A);
}
extern uint64_t rob971(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob971(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob971(structIterations, A);
}
extern uint64_t rob972(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob972(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob972(structIterations, A);
}
extern uint64_t rob973(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob973(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob973(structIterations, A);
}
extern uint64_t rob974(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob974(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob974(structIterations, A);
}
extern uint64_t rob975(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob975(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob975(structIterations, A);
}
extern uint64_t rob976(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob976(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob976(structIterations, A);
}
extern uint64_t rob977(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob977(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob977(structIterations, A);
}
extern uint64_t rob978(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob978(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob978(structIterations, A);
}
extern uint64_t rob979(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob979(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob979(structIterations, A);
}
extern uint64_t rob980(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob980(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob980(structIterations, A);
}
extern uint64_t rob981(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob981(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob981(structIterations, A);
}
extern uint64_t rob982(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob982(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob982(structIterations, A);
}
extern uint64_t rob983(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob983(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob983(structIterations, A);
}
extern uint64_t rob984(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob984(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob984(structIterations, A);
}
extern uint64_t rob985(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob985(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob985(structIterations, A);
}
extern uint64_t rob986(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob986(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob986(structIterations, A);
}
extern uint64_t rob987(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob987(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob987(structIterations, A);
}
extern uint64_t rob988(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob988(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob988(structIterations, A);
}
extern uint64_t rob989(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob989(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob989(structIterations, A);
}
extern uint64_t rob990(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob990(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob990(structIterations, A);
}
extern uint64_t rob991(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob991(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob991(structIterations, A);
}
extern uint64_t rob992(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob992(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob992(structIterations, A);
}
extern uint64_t rob993(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob993(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob993(structIterations, A);
}
extern uint64_t rob994(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob994(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob994(structIterations, A);
}
extern uint64_t rob995(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob995(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob995(structIterations, A);
}
extern uint64_t rob996(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob996(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob996(structIterations, A);
}
extern uint64_t rob997(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob997(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob997(structIterations, A);
}
extern uint64_t rob998(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob998(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob998(structIterations, A);
}
extern uint64_t rob999(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob999(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob999(structIterations, A);
}
extern uint64_t rob1000(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1000(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1000(structIterations, A);
}
extern uint64_t rob1001(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1001(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1001(structIterations, A);
}
extern uint64_t rob1002(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1002(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1002(structIterations, A);
}
extern uint64_t rob1003(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1003(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1003(structIterations, A);
}
extern uint64_t rob1004(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1004(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1004(structIterations, A);
}
extern uint64_t rob1005(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1005(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1005(structIterations, A);
}
extern uint64_t rob1006(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1006(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1006(structIterations, A);
}
extern uint64_t rob1007(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1007(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1007(structIterations, A);
}
extern uint64_t rob1008(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1008(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1008(structIterations, A);
}
extern uint64_t rob1009(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1009(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1009(structIterations, A);
}
extern uint64_t rob1010(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1010(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1010(structIterations, A);
}
extern uint64_t rob1011(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1011(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1011(structIterations, A);
}
extern uint64_t rob1012(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1012(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1012(structIterations, A);
}
extern uint64_t rob1013(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1013(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1013(structIterations, A);
}
extern uint64_t rob1014(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1014(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1014(structIterations, A);
}
extern uint64_t rob1015(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1015(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1015(structIterations, A);
}
extern uint64_t rob1016(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1016(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1016(structIterations, A);
}
extern uint64_t rob1017(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1017(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1017(structIterations, A);
}
extern uint64_t rob1018(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1018(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1018(structIterations, A);
}
extern uint64_t rob1019(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1019(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1019(structIterations, A);
}
extern uint64_t rob1020(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1020(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1020(structIterations, A);
}
extern uint64_t rob1021(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1021(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1021(structIterations, A);
}
extern uint64_t rob1022(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1022(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1022(structIterations, A);
}
extern uint64_t rob1023(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1023(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1023(structIterations, A);
}
extern uint64_t rob1024(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_rob1024(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    rob1024(structIterations, A);
}
extern uint64_t zerorob1(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob1(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob1(structIterations, A);
}
extern uint64_t zerorob2(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob2(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob2(structIterations, A);
}
extern uint64_t zerorob3(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob3(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob3(structIterations, A);
}
extern uint64_t zerorob4(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob4(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob4(structIterations, A);
}
extern uint64_t zerorob5(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob5(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob5(structIterations, A);
}
extern uint64_t zerorob6(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob6(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob6(structIterations, A);
}
extern uint64_t zerorob7(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob7(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob7(structIterations, A);
}
extern uint64_t zerorob8(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob8(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob8(structIterations, A);
}
extern uint64_t zerorob9(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob9(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob9(structIterations, A);
}
extern uint64_t zerorob10(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob10(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob10(structIterations, A);
}
extern uint64_t zerorob11(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob11(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob11(structIterations, A);
}
extern uint64_t zerorob12(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob12(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob12(structIterations, A);
}
extern uint64_t zerorob13(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob13(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob13(structIterations, A);
}
extern uint64_t zerorob14(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob14(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob14(structIterations, A);
}
extern uint64_t zerorob15(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob15(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob15(structIterations, A);
}
extern uint64_t zerorob16(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob16(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob16(structIterations, A);
}
extern uint64_t zerorob17(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob17(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob17(structIterations, A);
}
extern uint64_t zerorob18(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob18(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob18(structIterations, A);
}
extern uint64_t zerorob19(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob19(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob19(structIterations, A);
}
extern uint64_t zerorob20(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob20(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob20(structIterations, A);
}
extern uint64_t zerorob21(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob21(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob21(structIterations, A);
}
extern uint64_t zerorob22(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob22(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob22(structIterations, A);
}
extern uint64_t zerorob23(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob23(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob23(structIterations, A);
}
extern uint64_t zerorob24(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob24(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob24(structIterations, A);
}
extern uint64_t zerorob25(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob25(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob25(structIterations, A);
}
extern uint64_t zerorob26(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob26(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob26(structIterations, A);
}
extern uint64_t zerorob27(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob27(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob27(structIterations, A);
}
extern uint64_t zerorob28(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob28(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob28(structIterations, A);
}
extern uint64_t zerorob29(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob29(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob29(structIterations, A);
}
extern uint64_t zerorob30(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob30(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob30(structIterations, A);
}
extern uint64_t zerorob31(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob31(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob31(structIterations, A);
}
extern uint64_t zerorob32(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob32(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob32(structIterations, A);
}
extern uint64_t zerorob33(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob33(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob33(structIterations, A);
}
extern uint64_t zerorob34(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob34(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob34(structIterations, A);
}
extern uint64_t zerorob35(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob35(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob35(structIterations, A);
}
extern uint64_t zerorob36(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob36(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob36(structIterations, A);
}
extern uint64_t zerorob37(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob37(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob37(structIterations, A);
}
extern uint64_t zerorob38(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob38(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob38(structIterations, A);
}
extern uint64_t zerorob39(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob39(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob39(structIterations, A);
}
extern uint64_t zerorob40(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob40(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob40(structIterations, A);
}
extern uint64_t zerorob41(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob41(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob41(structIterations, A);
}
extern uint64_t zerorob42(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob42(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob42(structIterations, A);
}
extern uint64_t zerorob43(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob43(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob43(structIterations, A);
}
extern uint64_t zerorob44(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob44(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob44(structIterations, A);
}
extern uint64_t zerorob45(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob45(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob45(structIterations, A);
}
extern uint64_t zerorob46(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob46(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob46(structIterations, A);
}
extern uint64_t zerorob47(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob47(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob47(structIterations, A);
}
extern uint64_t zerorob48(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob48(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob48(structIterations, A);
}
extern uint64_t zerorob49(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob49(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob49(structIterations, A);
}
extern uint64_t zerorob50(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob50(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob50(structIterations, A);
}
extern uint64_t zerorob51(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob51(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob51(structIterations, A);
}
extern uint64_t zerorob52(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob52(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob52(structIterations, A);
}
extern uint64_t zerorob53(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob53(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob53(structIterations, A);
}
extern uint64_t zerorob54(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob54(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob54(structIterations, A);
}
extern uint64_t zerorob55(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob55(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob55(structIterations, A);
}
extern uint64_t zerorob56(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob56(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob56(structIterations, A);
}
extern uint64_t zerorob57(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob57(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob57(structIterations, A);
}
extern uint64_t zerorob58(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob58(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob58(structIterations, A);
}
extern uint64_t zerorob59(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob59(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob59(structIterations, A);
}
extern uint64_t zerorob60(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob60(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob60(structIterations, A);
}
extern uint64_t zerorob61(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob61(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob61(structIterations, A);
}
extern uint64_t zerorob62(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob62(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob62(structIterations, A);
}
extern uint64_t zerorob63(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob63(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob63(structIterations, A);
}
extern uint64_t zerorob64(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob64(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob64(structIterations, A);
}
extern uint64_t zerorob65(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob65(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob65(structIterations, A);
}
extern uint64_t zerorob66(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob66(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob66(structIterations, A);
}
extern uint64_t zerorob67(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob67(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob67(structIterations, A);
}
extern uint64_t zerorob68(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob68(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob68(structIterations, A);
}
extern uint64_t zerorob69(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob69(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob69(structIterations, A);
}
extern uint64_t zerorob70(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob70(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob70(structIterations, A);
}
extern uint64_t zerorob71(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob71(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob71(structIterations, A);
}
extern uint64_t zerorob72(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob72(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob72(structIterations, A);
}
extern uint64_t zerorob73(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob73(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob73(structIterations, A);
}
extern uint64_t zerorob74(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob74(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob74(structIterations, A);
}
extern uint64_t zerorob75(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob75(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob75(structIterations, A);
}
extern uint64_t zerorob76(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob76(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob76(structIterations, A);
}
extern uint64_t zerorob77(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob77(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob77(structIterations, A);
}
extern uint64_t zerorob78(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob78(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob78(structIterations, A);
}
extern uint64_t zerorob79(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob79(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob79(structIterations, A);
}
extern uint64_t zerorob80(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob80(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob80(structIterations, A);
}
extern uint64_t zerorob81(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob81(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob81(structIterations, A);
}
extern uint64_t zerorob82(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob82(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob82(structIterations, A);
}
extern uint64_t zerorob83(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob83(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob83(structIterations, A);
}
extern uint64_t zerorob84(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob84(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob84(structIterations, A);
}
extern uint64_t zerorob85(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob85(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob85(structIterations, A);
}
extern uint64_t zerorob86(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob86(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob86(structIterations, A);
}
extern uint64_t zerorob87(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob87(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob87(structIterations, A);
}
extern uint64_t zerorob88(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob88(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob88(structIterations, A);
}
extern uint64_t zerorob89(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob89(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob89(structIterations, A);
}
extern uint64_t zerorob90(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob90(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob90(structIterations, A);
}
extern uint64_t zerorob91(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob91(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob91(structIterations, A);
}
extern uint64_t zerorob92(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob92(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob92(structIterations, A);
}
extern uint64_t zerorob93(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob93(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob93(structIterations, A);
}
extern uint64_t zerorob94(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob94(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob94(structIterations, A);
}
extern uint64_t zerorob95(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob95(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob95(structIterations, A);
}
extern uint64_t zerorob96(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob96(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob96(structIterations, A);
}
extern uint64_t zerorob97(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob97(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob97(structIterations, A);
}
extern uint64_t zerorob98(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob98(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob98(structIterations, A);
}
extern uint64_t zerorob99(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob99(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob99(structIterations, A);
}
extern uint64_t zerorob100(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob100(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob100(structIterations, A);
}
extern uint64_t zerorob101(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob101(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob101(structIterations, A);
}
extern uint64_t zerorob102(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob102(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob102(structIterations, A);
}
extern uint64_t zerorob103(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob103(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob103(structIterations, A);
}
extern uint64_t zerorob104(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob104(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob104(structIterations, A);
}
extern uint64_t zerorob105(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob105(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob105(structIterations, A);
}
extern uint64_t zerorob106(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob106(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob106(structIterations, A);
}
extern uint64_t zerorob107(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob107(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob107(structIterations, A);
}
extern uint64_t zerorob108(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob108(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob108(structIterations, A);
}
extern uint64_t zerorob109(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob109(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob109(structIterations, A);
}
extern uint64_t zerorob110(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob110(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob110(structIterations, A);
}
extern uint64_t zerorob111(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob111(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob111(structIterations, A);
}
extern uint64_t zerorob112(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob112(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob112(structIterations, A);
}
extern uint64_t zerorob113(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob113(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob113(structIterations, A);
}
extern uint64_t zerorob114(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob114(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob114(structIterations, A);
}
extern uint64_t zerorob115(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob115(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob115(structIterations, A);
}
extern uint64_t zerorob116(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob116(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob116(structIterations, A);
}
extern uint64_t zerorob117(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob117(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob117(structIterations, A);
}
extern uint64_t zerorob118(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob118(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob118(structIterations, A);
}
extern uint64_t zerorob119(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob119(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob119(structIterations, A);
}
extern uint64_t zerorob120(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob120(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob120(structIterations, A);
}
extern uint64_t zerorob121(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob121(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob121(structIterations, A);
}
extern uint64_t zerorob122(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob122(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob122(structIterations, A);
}
extern uint64_t zerorob123(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob123(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob123(structIterations, A);
}
extern uint64_t zerorob124(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob124(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob124(structIterations, A);
}
extern uint64_t zerorob125(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob125(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob125(structIterations, A);
}
extern uint64_t zerorob126(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob126(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob126(structIterations, A);
}
extern uint64_t zerorob127(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob127(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob127(structIterations, A);
}
extern uint64_t zerorob128(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob128(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob128(structIterations, A);
}
extern uint64_t zerorob129(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob129(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob129(structIterations, A);
}
extern uint64_t zerorob130(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob130(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob130(structIterations, A);
}
extern uint64_t zerorob131(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob131(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob131(structIterations, A);
}
extern uint64_t zerorob132(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob132(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob132(structIterations, A);
}
extern uint64_t zerorob133(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob133(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob133(structIterations, A);
}
extern uint64_t zerorob134(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob134(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob134(structIterations, A);
}
extern uint64_t zerorob135(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob135(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob135(structIterations, A);
}
extern uint64_t zerorob136(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob136(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob136(structIterations, A);
}
extern uint64_t zerorob137(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob137(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob137(structIterations, A);
}
extern uint64_t zerorob138(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob138(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob138(structIterations, A);
}
extern uint64_t zerorob139(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob139(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob139(structIterations, A);
}
extern uint64_t zerorob140(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob140(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob140(structIterations, A);
}
extern uint64_t zerorob141(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob141(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob141(structIterations, A);
}
extern uint64_t zerorob142(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob142(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob142(structIterations, A);
}
extern uint64_t zerorob143(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob143(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob143(structIterations, A);
}
extern uint64_t zerorob144(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob144(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob144(structIterations, A);
}
extern uint64_t zerorob145(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob145(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob145(structIterations, A);
}
extern uint64_t zerorob146(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob146(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob146(structIterations, A);
}
extern uint64_t zerorob147(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob147(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob147(structIterations, A);
}
extern uint64_t zerorob148(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob148(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob148(structIterations, A);
}
extern uint64_t zerorob149(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob149(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob149(structIterations, A);
}
extern uint64_t zerorob150(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob150(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob150(structIterations, A);
}
extern uint64_t zerorob151(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob151(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob151(structIterations, A);
}
extern uint64_t zerorob152(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob152(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob152(structIterations, A);
}
extern uint64_t zerorob153(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob153(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob153(structIterations, A);
}
extern uint64_t zerorob154(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob154(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob154(structIterations, A);
}
extern uint64_t zerorob155(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob155(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob155(structIterations, A);
}
extern uint64_t zerorob156(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob156(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob156(structIterations, A);
}
extern uint64_t zerorob157(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob157(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob157(structIterations, A);
}
extern uint64_t zerorob158(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob158(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob158(structIterations, A);
}
extern uint64_t zerorob159(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob159(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob159(structIterations, A);
}
extern uint64_t zerorob160(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob160(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob160(structIterations, A);
}
extern uint64_t zerorob161(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob161(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob161(structIterations, A);
}
extern uint64_t zerorob162(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob162(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob162(structIterations, A);
}
extern uint64_t zerorob163(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob163(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob163(structIterations, A);
}
extern uint64_t zerorob164(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob164(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob164(structIterations, A);
}
extern uint64_t zerorob165(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob165(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob165(structIterations, A);
}
extern uint64_t zerorob166(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob166(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob166(structIterations, A);
}
extern uint64_t zerorob167(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob167(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob167(structIterations, A);
}
extern uint64_t zerorob168(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob168(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob168(structIterations, A);
}
extern uint64_t zerorob169(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob169(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob169(structIterations, A);
}
extern uint64_t zerorob170(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob170(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob170(structIterations, A);
}
extern uint64_t zerorob171(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob171(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob171(structIterations, A);
}
extern uint64_t zerorob172(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob172(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob172(structIterations, A);
}
extern uint64_t zerorob173(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob173(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob173(structIterations, A);
}
extern uint64_t zerorob174(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob174(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob174(structIterations, A);
}
extern uint64_t zerorob175(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob175(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob175(structIterations, A);
}
extern uint64_t zerorob176(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob176(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob176(structIterations, A);
}
extern uint64_t zerorob177(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob177(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob177(structIterations, A);
}
extern uint64_t zerorob178(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob178(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob178(structIterations, A);
}
extern uint64_t zerorob179(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob179(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob179(structIterations, A);
}
extern uint64_t zerorob180(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob180(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob180(structIterations, A);
}
extern uint64_t zerorob181(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob181(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob181(structIterations, A);
}
extern uint64_t zerorob182(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob182(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob182(structIterations, A);
}
extern uint64_t zerorob183(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob183(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob183(structIterations, A);
}
extern uint64_t zerorob184(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob184(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob184(structIterations, A);
}
extern uint64_t zerorob185(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob185(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob185(structIterations, A);
}
extern uint64_t zerorob186(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob186(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob186(structIterations, A);
}
extern uint64_t zerorob187(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob187(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob187(structIterations, A);
}
extern uint64_t zerorob188(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob188(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob188(structIterations, A);
}
extern uint64_t zerorob189(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob189(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob189(structIterations, A);
}
extern uint64_t zerorob190(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob190(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob190(structIterations, A);
}
extern uint64_t zerorob191(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob191(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob191(structIterations, A);
}
extern uint64_t zerorob192(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob192(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob192(structIterations, A);
}
extern uint64_t zerorob193(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob193(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob193(structIterations, A);
}
extern uint64_t zerorob194(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob194(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob194(structIterations, A);
}
extern uint64_t zerorob195(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob195(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob195(structIterations, A);
}
extern uint64_t zerorob196(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob196(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob196(structIterations, A);
}
extern uint64_t zerorob197(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob197(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob197(structIterations, A);
}
extern uint64_t zerorob198(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob198(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob198(structIterations, A);
}
extern uint64_t zerorob199(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob199(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob199(structIterations, A);
}
extern uint64_t zerorob200(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob200(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob200(structIterations, A);
}
extern uint64_t zerorob201(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob201(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob201(structIterations, A);
}
extern uint64_t zerorob202(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob202(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob202(structIterations, A);
}
extern uint64_t zerorob203(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob203(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob203(structIterations, A);
}
extern uint64_t zerorob204(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob204(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob204(structIterations, A);
}
extern uint64_t zerorob205(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob205(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob205(structIterations, A);
}
extern uint64_t zerorob206(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob206(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob206(structIterations, A);
}
extern uint64_t zerorob207(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob207(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob207(structIterations, A);
}
extern uint64_t zerorob208(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob208(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob208(structIterations, A);
}
extern uint64_t zerorob209(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob209(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob209(structIterations, A);
}
extern uint64_t zerorob210(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob210(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob210(structIterations, A);
}
extern uint64_t zerorob211(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob211(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob211(structIterations, A);
}
extern uint64_t zerorob212(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob212(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob212(structIterations, A);
}
extern uint64_t zerorob213(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob213(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob213(structIterations, A);
}
extern uint64_t zerorob214(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob214(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob214(structIterations, A);
}
extern uint64_t zerorob215(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob215(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob215(structIterations, A);
}
extern uint64_t zerorob216(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob216(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob216(structIterations, A);
}
extern uint64_t zerorob217(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob217(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob217(structIterations, A);
}
extern uint64_t zerorob218(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob218(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob218(structIterations, A);
}
extern uint64_t zerorob219(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob219(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob219(structIterations, A);
}
extern uint64_t zerorob220(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob220(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob220(structIterations, A);
}
extern uint64_t zerorob221(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob221(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob221(structIterations, A);
}
extern uint64_t zerorob222(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob222(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob222(structIterations, A);
}
extern uint64_t zerorob223(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob223(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob223(structIterations, A);
}
extern uint64_t zerorob224(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob224(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob224(structIterations, A);
}
extern uint64_t zerorob225(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob225(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob225(structIterations, A);
}
extern uint64_t zerorob226(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob226(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob226(structIterations, A);
}
extern uint64_t zerorob227(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob227(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob227(structIterations, A);
}
extern uint64_t zerorob228(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob228(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob228(structIterations, A);
}
extern uint64_t zerorob229(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob229(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob229(structIterations, A);
}
extern uint64_t zerorob230(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob230(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob230(structIterations, A);
}
extern uint64_t zerorob231(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob231(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob231(structIterations, A);
}
extern uint64_t zerorob232(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob232(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob232(structIterations, A);
}
extern uint64_t zerorob233(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob233(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob233(structIterations, A);
}
extern uint64_t zerorob234(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob234(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob234(structIterations, A);
}
extern uint64_t zerorob235(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob235(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob235(structIterations, A);
}
extern uint64_t zerorob236(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob236(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob236(structIterations, A);
}
extern uint64_t zerorob237(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob237(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob237(structIterations, A);
}
extern uint64_t zerorob238(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob238(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob238(structIterations, A);
}
extern uint64_t zerorob239(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob239(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob239(structIterations, A);
}
extern uint64_t zerorob240(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob240(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob240(structIterations, A);
}
extern uint64_t zerorob241(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob241(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob241(structIterations, A);
}
extern uint64_t zerorob242(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob242(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob242(structIterations, A);
}
extern uint64_t zerorob243(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob243(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob243(structIterations, A);
}
extern uint64_t zerorob244(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob244(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob244(structIterations, A);
}
extern uint64_t zerorob245(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob245(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob245(structIterations, A);
}
extern uint64_t zerorob246(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob246(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob246(structIterations, A);
}
extern uint64_t zerorob247(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob247(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob247(structIterations, A);
}
extern uint64_t zerorob248(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob248(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob248(structIterations, A);
}
extern uint64_t zerorob249(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob249(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob249(structIterations, A);
}
extern uint64_t zerorob250(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob250(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob250(structIterations, A);
}
extern uint64_t zerorob251(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob251(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob251(structIterations, A);
}
extern uint64_t zerorob252(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob252(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob252(structIterations, A);
}
extern uint64_t zerorob253(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob253(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob253(structIterations, A);
}
extern uint64_t zerorob254(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob254(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob254(structIterations, A);
}
extern uint64_t zerorob255(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob255(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob255(structIterations, A);
}
extern uint64_t zerorob256(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob256(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob256(structIterations, A);
}
extern uint64_t zerorob257(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob257(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob257(structIterations, A);
}
extern uint64_t zerorob258(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob258(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob258(structIterations, A);
}
extern uint64_t zerorob259(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob259(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob259(structIterations, A);
}
extern uint64_t zerorob260(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob260(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob260(structIterations, A);
}
extern uint64_t zerorob261(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob261(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob261(structIterations, A);
}
extern uint64_t zerorob262(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob262(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob262(structIterations, A);
}
extern uint64_t zerorob263(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob263(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob263(structIterations, A);
}
extern uint64_t zerorob264(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob264(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob264(structIterations, A);
}
extern uint64_t zerorob265(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob265(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob265(structIterations, A);
}
extern uint64_t zerorob266(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob266(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob266(structIterations, A);
}
extern uint64_t zerorob267(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob267(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob267(structIterations, A);
}
extern uint64_t zerorob268(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob268(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob268(structIterations, A);
}
extern uint64_t zerorob269(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob269(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob269(structIterations, A);
}
extern uint64_t zerorob270(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob270(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob270(structIterations, A);
}
extern uint64_t zerorob271(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob271(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob271(structIterations, A);
}
extern uint64_t zerorob272(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob272(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob272(structIterations, A);
}
extern uint64_t zerorob273(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob273(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob273(structIterations, A);
}
extern uint64_t zerorob274(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob274(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob274(structIterations, A);
}
extern uint64_t zerorob275(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob275(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob275(structIterations, A);
}
extern uint64_t zerorob276(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob276(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob276(structIterations, A);
}
extern uint64_t zerorob277(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob277(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob277(structIterations, A);
}
extern uint64_t zerorob278(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob278(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob278(structIterations, A);
}
extern uint64_t zerorob279(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob279(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob279(structIterations, A);
}
extern uint64_t zerorob280(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob280(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob280(structIterations, A);
}
extern uint64_t zerorob281(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob281(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob281(structIterations, A);
}
extern uint64_t zerorob282(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob282(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob282(structIterations, A);
}
extern uint64_t zerorob283(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob283(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob283(structIterations, A);
}
extern uint64_t zerorob284(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob284(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob284(structIterations, A);
}
extern uint64_t zerorob285(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob285(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob285(structIterations, A);
}
extern uint64_t zerorob286(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob286(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob286(structIterations, A);
}
extern uint64_t zerorob287(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob287(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob287(structIterations, A);
}
extern uint64_t zerorob288(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob288(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob288(structIterations, A);
}
extern uint64_t zerorob289(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob289(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob289(structIterations, A);
}
extern uint64_t zerorob290(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob290(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob290(structIterations, A);
}
extern uint64_t zerorob291(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob291(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob291(structIterations, A);
}
extern uint64_t zerorob292(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob292(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob292(structIterations, A);
}
extern uint64_t zerorob293(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob293(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob293(structIterations, A);
}
extern uint64_t zerorob294(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob294(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob294(structIterations, A);
}
extern uint64_t zerorob295(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob295(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob295(structIterations, A);
}
extern uint64_t zerorob296(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob296(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob296(structIterations, A);
}
extern uint64_t zerorob297(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob297(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob297(structIterations, A);
}
extern uint64_t zerorob298(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob298(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob298(structIterations, A);
}
extern uint64_t zerorob299(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob299(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob299(structIterations, A);
}
extern uint64_t zerorob300(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob300(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob300(structIterations, A);
}
extern uint64_t zerorob301(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob301(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob301(structIterations, A);
}
extern uint64_t zerorob302(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob302(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob302(structIterations, A);
}
extern uint64_t zerorob303(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob303(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob303(structIterations, A);
}
extern uint64_t zerorob304(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob304(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob304(structIterations, A);
}
extern uint64_t zerorob305(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob305(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob305(structIterations, A);
}
extern uint64_t zerorob306(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob306(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob306(structIterations, A);
}
extern uint64_t zerorob307(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob307(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob307(structIterations, A);
}
extern uint64_t zerorob308(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob308(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob308(structIterations, A);
}
extern uint64_t zerorob309(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob309(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob309(structIterations, A);
}
extern uint64_t zerorob310(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob310(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob310(structIterations, A);
}
extern uint64_t zerorob311(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob311(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob311(structIterations, A);
}
extern uint64_t zerorob312(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob312(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob312(structIterations, A);
}
extern uint64_t zerorob313(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob313(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob313(structIterations, A);
}
extern uint64_t zerorob314(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob314(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob314(structIterations, A);
}
extern uint64_t zerorob315(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob315(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob315(structIterations, A);
}
extern uint64_t zerorob316(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob316(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob316(structIterations, A);
}
extern uint64_t zerorob317(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob317(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob317(structIterations, A);
}
extern uint64_t zerorob318(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob318(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob318(structIterations, A);
}
extern uint64_t zerorob319(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob319(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob319(structIterations, A);
}
extern uint64_t zerorob320(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob320(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob320(structIterations, A);
}
extern uint64_t zerorob321(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob321(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob321(structIterations, A);
}
extern uint64_t zerorob322(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob322(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob322(structIterations, A);
}
extern uint64_t zerorob323(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob323(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob323(structIterations, A);
}
extern uint64_t zerorob324(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob324(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob324(structIterations, A);
}
extern uint64_t zerorob325(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob325(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob325(structIterations, A);
}
extern uint64_t zerorob326(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob326(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob326(structIterations, A);
}
extern uint64_t zerorob327(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob327(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob327(structIterations, A);
}
extern uint64_t zerorob328(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob328(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob328(structIterations, A);
}
extern uint64_t zerorob329(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob329(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob329(structIterations, A);
}
extern uint64_t zerorob330(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob330(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob330(structIterations, A);
}
extern uint64_t zerorob331(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob331(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob331(structIterations, A);
}
extern uint64_t zerorob332(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob332(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob332(structIterations, A);
}
extern uint64_t zerorob333(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob333(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob333(structIterations, A);
}
extern uint64_t zerorob334(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob334(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob334(structIterations, A);
}
extern uint64_t zerorob335(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob335(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob335(structIterations, A);
}
extern uint64_t zerorob336(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob336(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob336(structIterations, A);
}
extern uint64_t zerorob337(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob337(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob337(structIterations, A);
}
extern uint64_t zerorob338(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob338(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob338(structIterations, A);
}
extern uint64_t zerorob339(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob339(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob339(structIterations, A);
}
extern uint64_t zerorob340(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob340(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob340(structIterations, A);
}
extern uint64_t zerorob341(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob341(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob341(structIterations, A);
}
extern uint64_t zerorob342(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob342(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob342(structIterations, A);
}
extern uint64_t zerorob343(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob343(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob343(structIterations, A);
}
extern uint64_t zerorob344(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob344(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob344(structIterations, A);
}
extern uint64_t zerorob345(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob345(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob345(structIterations, A);
}
extern uint64_t zerorob346(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob346(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob346(structIterations, A);
}
extern uint64_t zerorob347(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob347(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob347(structIterations, A);
}
extern uint64_t zerorob348(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob348(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob348(structIterations, A);
}
extern uint64_t zerorob349(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob349(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob349(structIterations, A);
}
extern uint64_t zerorob350(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob350(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob350(structIterations, A);
}
extern uint64_t zerorob351(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob351(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob351(structIterations, A);
}
extern uint64_t zerorob352(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob352(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob352(structIterations, A);
}
extern uint64_t zerorob353(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob353(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob353(structIterations, A);
}
extern uint64_t zerorob354(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob354(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob354(structIterations, A);
}
extern uint64_t zerorob355(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob355(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob355(structIterations, A);
}
extern uint64_t zerorob356(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob356(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob356(structIterations, A);
}
extern uint64_t zerorob357(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob357(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob357(structIterations, A);
}
extern uint64_t zerorob358(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob358(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob358(structIterations, A);
}
extern uint64_t zerorob359(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob359(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob359(structIterations, A);
}
extern uint64_t zerorob360(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob360(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob360(structIterations, A);
}
extern uint64_t zerorob361(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob361(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob361(structIterations, A);
}
extern uint64_t zerorob362(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob362(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob362(structIterations, A);
}
extern uint64_t zerorob363(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob363(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob363(structIterations, A);
}
extern uint64_t zerorob364(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob364(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob364(structIterations, A);
}
extern uint64_t zerorob365(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob365(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob365(structIterations, A);
}
extern uint64_t zerorob366(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob366(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob366(structIterations, A);
}
extern uint64_t zerorob367(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob367(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob367(structIterations, A);
}
extern uint64_t zerorob368(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob368(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob368(structIterations, A);
}
extern uint64_t zerorob369(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob369(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob369(structIterations, A);
}
extern uint64_t zerorob370(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob370(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob370(structIterations, A);
}
extern uint64_t zerorob371(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob371(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob371(structIterations, A);
}
extern uint64_t zerorob372(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob372(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob372(structIterations, A);
}
extern uint64_t zerorob373(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob373(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob373(structIterations, A);
}
extern uint64_t zerorob374(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob374(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob374(structIterations, A);
}
extern uint64_t zerorob375(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob375(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob375(structIterations, A);
}
extern uint64_t zerorob376(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob376(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob376(structIterations, A);
}
extern uint64_t zerorob377(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob377(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob377(structIterations, A);
}
extern uint64_t zerorob378(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob378(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob378(structIterations, A);
}
extern uint64_t zerorob379(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob379(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob379(structIterations, A);
}
extern uint64_t zerorob380(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob380(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob380(structIterations, A);
}
extern uint64_t zerorob381(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob381(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob381(structIterations, A);
}
extern uint64_t zerorob382(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob382(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob382(structIterations, A);
}
extern uint64_t zerorob383(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob383(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob383(structIterations, A);
}
extern uint64_t zerorob384(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob384(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob384(structIterations, A);
}
extern uint64_t zerorob385(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob385(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob385(structIterations, A);
}
extern uint64_t zerorob386(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob386(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob386(structIterations, A);
}
extern uint64_t zerorob387(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob387(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob387(structIterations, A);
}
extern uint64_t zerorob388(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob388(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob388(structIterations, A);
}
extern uint64_t zerorob389(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob389(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob389(structIterations, A);
}
extern uint64_t zerorob390(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob390(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob390(structIterations, A);
}
extern uint64_t zerorob391(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob391(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob391(structIterations, A);
}
extern uint64_t zerorob392(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob392(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob392(structIterations, A);
}
extern uint64_t zerorob393(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob393(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob393(structIterations, A);
}
extern uint64_t zerorob394(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob394(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob394(structIterations, A);
}
extern uint64_t zerorob395(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob395(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob395(structIterations, A);
}
extern uint64_t zerorob396(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob396(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob396(structIterations, A);
}
extern uint64_t zerorob397(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob397(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob397(structIterations, A);
}
extern uint64_t zerorob398(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob398(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob398(structIterations, A);
}
extern uint64_t zerorob399(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob399(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob399(structIterations, A);
}
extern uint64_t zerorob400(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob400(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob400(structIterations, A);
}
extern uint64_t zerorob401(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob401(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob401(structIterations, A);
}
extern uint64_t zerorob402(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob402(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob402(structIterations, A);
}
extern uint64_t zerorob403(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob403(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob403(structIterations, A);
}
extern uint64_t zerorob404(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob404(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob404(structIterations, A);
}
extern uint64_t zerorob405(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob405(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob405(structIterations, A);
}
extern uint64_t zerorob406(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob406(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob406(structIterations, A);
}
extern uint64_t zerorob407(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob407(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob407(structIterations, A);
}
extern uint64_t zerorob408(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob408(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob408(structIterations, A);
}
extern uint64_t zerorob409(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob409(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob409(structIterations, A);
}
extern uint64_t zerorob410(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob410(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob410(structIterations, A);
}
extern uint64_t zerorob411(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob411(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob411(structIterations, A);
}
extern uint64_t zerorob412(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob412(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob412(structIterations, A);
}
extern uint64_t zerorob413(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob413(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob413(structIterations, A);
}
extern uint64_t zerorob414(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob414(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob414(structIterations, A);
}
extern uint64_t zerorob415(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob415(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob415(structIterations, A);
}
extern uint64_t zerorob416(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob416(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob416(structIterations, A);
}
extern uint64_t zerorob417(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob417(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob417(structIterations, A);
}
extern uint64_t zerorob418(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob418(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob418(structIterations, A);
}
extern uint64_t zerorob419(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob419(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob419(structIterations, A);
}
extern uint64_t zerorob420(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob420(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob420(structIterations, A);
}
extern uint64_t zerorob421(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob421(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob421(structIterations, A);
}
extern uint64_t zerorob422(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob422(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob422(structIterations, A);
}
extern uint64_t zerorob423(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob423(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob423(structIterations, A);
}
extern uint64_t zerorob424(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob424(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob424(structIterations, A);
}
extern uint64_t zerorob425(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob425(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob425(structIterations, A);
}
extern uint64_t zerorob426(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob426(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob426(structIterations, A);
}
extern uint64_t zerorob427(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob427(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob427(structIterations, A);
}
extern uint64_t zerorob428(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob428(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob428(structIterations, A);
}
extern uint64_t zerorob429(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob429(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob429(structIterations, A);
}
extern uint64_t zerorob430(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob430(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob430(structIterations, A);
}
extern uint64_t zerorob431(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob431(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob431(structIterations, A);
}
extern uint64_t zerorob432(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob432(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob432(structIterations, A);
}
extern uint64_t zerorob433(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob433(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob433(structIterations, A);
}
extern uint64_t zerorob434(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob434(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob434(structIterations, A);
}
extern uint64_t zerorob435(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob435(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob435(structIterations, A);
}
extern uint64_t zerorob436(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob436(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob436(structIterations, A);
}
extern uint64_t zerorob437(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob437(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob437(structIterations, A);
}
extern uint64_t zerorob438(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob438(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob438(structIterations, A);
}
extern uint64_t zerorob439(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob439(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob439(structIterations, A);
}
extern uint64_t zerorob440(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob440(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob440(structIterations, A);
}
extern uint64_t zerorob441(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob441(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob441(structIterations, A);
}
extern uint64_t zerorob442(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob442(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob442(structIterations, A);
}
extern uint64_t zerorob443(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob443(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob443(structIterations, A);
}
extern uint64_t zerorob444(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob444(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob444(structIterations, A);
}
extern uint64_t zerorob445(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob445(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob445(structIterations, A);
}
extern uint64_t zerorob446(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob446(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob446(structIterations, A);
}
extern uint64_t zerorob447(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob447(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob447(structIterations, A);
}
extern uint64_t zerorob448(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob448(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob448(structIterations, A);
}
extern uint64_t zerorob449(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob449(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob449(structIterations, A);
}
extern uint64_t zerorob450(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob450(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob450(structIterations, A);
}
extern uint64_t zerorob451(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob451(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob451(structIterations, A);
}
extern uint64_t zerorob452(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob452(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob452(structIterations, A);
}
extern uint64_t zerorob453(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob453(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob453(structIterations, A);
}
extern uint64_t zerorob454(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob454(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob454(structIterations, A);
}
extern uint64_t zerorob455(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob455(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob455(structIterations, A);
}
extern uint64_t zerorob456(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob456(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob456(structIterations, A);
}
extern uint64_t zerorob457(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob457(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob457(structIterations, A);
}
extern uint64_t zerorob458(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob458(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob458(structIterations, A);
}
extern uint64_t zerorob459(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob459(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob459(structIterations, A);
}
extern uint64_t zerorob460(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob460(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob460(structIterations, A);
}
extern uint64_t zerorob461(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob461(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob461(structIterations, A);
}
extern uint64_t zerorob462(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob462(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob462(structIterations, A);
}
extern uint64_t zerorob463(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob463(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob463(structIterations, A);
}
extern uint64_t zerorob464(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob464(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob464(structIterations, A);
}
extern uint64_t zerorob465(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob465(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob465(structIterations, A);
}
extern uint64_t zerorob466(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob466(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob466(structIterations, A);
}
extern uint64_t zerorob467(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob467(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob467(structIterations, A);
}
extern uint64_t zerorob468(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob468(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob468(structIterations, A);
}
extern uint64_t zerorob469(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob469(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob469(structIterations, A);
}
extern uint64_t zerorob470(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob470(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob470(structIterations, A);
}
extern uint64_t zerorob471(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob471(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob471(structIterations, A);
}
extern uint64_t zerorob472(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob472(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob472(structIterations, A);
}
extern uint64_t zerorob473(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob473(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob473(structIterations, A);
}
extern uint64_t zerorob474(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob474(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob474(structIterations, A);
}
extern uint64_t zerorob475(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob475(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob475(structIterations, A);
}
extern uint64_t zerorob476(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob476(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob476(structIterations, A);
}
extern uint64_t zerorob477(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob477(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob477(structIterations, A);
}
extern uint64_t zerorob478(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob478(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob478(structIterations, A);
}
extern uint64_t zerorob479(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob479(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob479(structIterations, A);
}
extern uint64_t zerorob480(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob480(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob480(structIterations, A);
}
extern uint64_t zerorob481(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob481(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob481(structIterations, A);
}
extern uint64_t zerorob482(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob482(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob482(structIterations, A);
}
extern uint64_t zerorob483(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob483(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob483(structIterations, A);
}
extern uint64_t zerorob484(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob484(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob484(structIterations, A);
}
extern uint64_t zerorob485(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob485(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob485(structIterations, A);
}
extern uint64_t zerorob486(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob486(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob486(structIterations, A);
}
extern uint64_t zerorob487(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob487(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob487(structIterations, A);
}
extern uint64_t zerorob488(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob488(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob488(structIterations, A);
}
extern uint64_t zerorob489(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob489(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob489(structIterations, A);
}
extern uint64_t zerorob490(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob490(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob490(structIterations, A);
}
extern uint64_t zerorob491(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob491(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob491(structIterations, A);
}
extern uint64_t zerorob492(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob492(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob492(structIterations, A);
}
extern uint64_t zerorob493(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob493(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob493(structIterations, A);
}
extern uint64_t zerorob494(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob494(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob494(structIterations, A);
}
extern uint64_t zerorob495(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob495(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob495(structIterations, A);
}
extern uint64_t zerorob496(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob496(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob496(structIterations, A);
}
extern uint64_t zerorob497(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob497(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob497(structIterations, A);
}
extern uint64_t zerorob498(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob498(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob498(structIterations, A);
}
extern uint64_t zerorob499(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob499(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob499(structIterations, A);
}
extern uint64_t zerorob500(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob500(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob500(structIterations, A);
}
extern uint64_t zerorob501(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob501(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob501(structIterations, A);
}
extern uint64_t zerorob502(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob502(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob502(structIterations, A);
}
extern uint64_t zerorob503(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob503(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob503(structIterations, A);
}
extern uint64_t zerorob504(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob504(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob504(structIterations, A);
}
extern uint64_t zerorob505(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob505(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob505(structIterations, A);
}
extern uint64_t zerorob506(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob506(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob506(structIterations, A);
}
extern uint64_t zerorob507(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob507(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob507(structIterations, A);
}
extern uint64_t zerorob508(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob508(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob508(structIterations, A);
}
extern uint64_t zerorob509(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob509(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob509(structIterations, A);
}
extern uint64_t zerorob510(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob510(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob510(structIterations, A);
}
extern uint64_t zerorob511(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob511(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob511(structIterations, A);
}
extern uint64_t zerorob512(uint64_t iterations, int *arr) __attribute((sysv_abi));
void *ThreadLaunch_zerorob512(void *pa)
{
    struct ThreadData *td = (struct ThreadData *)pa;
    int *A = td->A;
    int *B = td->B;
    float *fpArr = td->fpArr;
    uint32_t list_size = td->list_size;
    int structIterations = td->structIterations;
    zerorob512(structIterations, A);
}
int main(int argc, char *argv[]) {
  uint64_t time_diff_ms, iterations = 500000000, structIterations = 5000000, tmp;
  double latency; int *A = NULL, *B = NULL; float *fpArr = NULL; char *test_name = NULL; int core_affinity = -1; int threads = 1;
  uint64_t tmpsink;
  uint32_t list_size = 33554432;
  printf("Usage: -test [test name] -listsize [latency list size = 33554432] -iterations [struct iterations = 5000000]\n");
  if (argc < 2) {
    printf("List of tests:\n");
    printf("  rob - Reorder Buffer Test\n");
    printf("  zerorob - Reorder Buffer Test with Zeroing Idioms\n");
  } else {
    for (int argIdx = 1; argIdx < argc; argIdx++) {
      if (*(argv[argIdx]) == '-') { char *arg = argv[argIdx] + 1;
        if (strncmp(arg, "test", 4) == 0) { argIdx++; test_name = argv[argIdx]; }
        if (strncmp(arg, "iterations", 10) == 0) { argIdx++; iterations = 100 * atoi(argv[argIdx]); }
        if (strncmp(arg, "listsize", 8) == 0) { argIdx++; list_size = atoi(argv[argIdx]); }
        if (strncmp(arg, "affinity", 8) == 0) { argIdx++; core_affinity = atoi(argv[argIdx]); }
        if (strncmp(arg, "threads", 7) == 0) { argIdx++; threads = atoi(argv[argIdx]); }
      }
    }
    if (test_name == NULL) { fprintf(stderr, "No test specified\n"); return 0; }
#ifndef __MINGW32__
  if (core_affinity != -1) setAffinity(core_affinity);
#endif
  if (argc == 1 || argc > 1 && strncmp(test_name, "btb", 3) != 0) {
  A = (int*)malloc(sizeof(int) * list_size);
  srand(time(NULL));
  FillPatternArr(A, list_size, 64);

#ifdef _WIN32
  B = (int*)_aligned_malloc(sizeof(int) * list_size, 64);

#else
  posix_memalign((void **)&B, 64, sizeof(int) * list_size);

#endif
  for (int i = 0; i < list_size; i++) { B[i] = i; }

  fpArr = (float*)malloc(sizeof(float) * list_size);

  for (int i = 0;i < list_size; i++) { fpArr[i] = i + .1; }

  }
  struct timeval startTv, endTv;
  struct timezone startTz, endTz;
  if (argc > 1 && strncmp(test_name, "rob", 3) == 0) {
    printf("Reorder Buffer Test:\n");
    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1(structIterations, A);
#else
    rob1(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob2, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob2(structIterations, A);
#else
    rob2(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("2,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob3, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob3(structIterations, A);
#else
    rob3(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("3,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob4, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob4(structIterations, A);
#else
    rob4(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("4,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob5, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob5(structIterations, A);
#else
    rob5(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("5,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob6, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob6(structIterations, A);
#else
    rob6(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("6,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob7, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob7(structIterations, A);
#else
    rob7(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("7,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob8, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob8(structIterations, A);
#else
    rob8(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("8,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob9, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob9(structIterations, A);
#else
    rob9(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("9,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob10, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob10(structIterations, A);
#else
    rob10(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("10,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob11, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob11(structIterations, A);
#else
    rob11(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("11,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob12, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob12(structIterations, A);
#else
    rob12(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("12,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob13, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob13(structIterations, A);
#else
    rob13(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("13,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob14, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob14(structIterations, A);
#else
    rob14(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("14,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob15, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob15(structIterations, A);
#else
    rob15(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("15,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob16, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob16(structIterations, A);
#else
    rob16(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("16,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob17, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob17(structIterations, A);
#else
    rob17(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("17,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob18, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob18(structIterations, A);
#else
    rob18(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("18,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob19, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob19(structIterations, A);
#else
    rob19(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("19,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob20, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob20(structIterations, A);
#else
    rob20(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("20,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob21, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob21(structIterations, A);
#else
    rob21(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("21,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob22, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob22(structIterations, A);
#else
    rob22(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("22,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob23, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob23(structIterations, A);
#else
    rob23(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("23,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob24, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob24(structIterations, A);
#else
    rob24(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("24,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob25, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob25(structIterations, A);
#else
    rob25(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("25,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob26, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob26(structIterations, A);
#else
    rob26(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("26,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob27, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob27(structIterations, A);
#else
    rob27(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("27,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob28, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob28(structIterations, A);
#else
    rob28(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("28,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob29, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob29(structIterations, A);
#else
    rob29(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("29,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob30, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob30(structIterations, A);
#else
    rob30(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("30,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob31, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob31(structIterations, A);
#else
    rob31(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("31,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob32, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob32(structIterations, A);
#else
    rob32(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("32,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob33, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob33(structIterations, A);
#else
    rob33(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("33,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob34, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob34(structIterations, A);
#else
    rob34(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("34,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob35, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob35(structIterations, A);
#else
    rob35(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("35,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob36, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob36(structIterations, A);
#else
    rob36(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("36,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob37, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob37(structIterations, A);
#else
    rob37(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("37,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob38, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob38(structIterations, A);
#else
    rob38(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("38,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob39, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob39(structIterations, A);
#else
    rob39(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("39,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob40, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob40(structIterations, A);
#else
    rob40(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("40,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob41, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob41(structIterations, A);
#else
    rob41(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("41,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob42, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob42(structIterations, A);
#else
    rob42(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("42,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob43, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob43(structIterations, A);
#else
    rob43(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("43,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob44, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob44(structIterations, A);
#else
    rob44(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("44,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob45, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob45(structIterations, A);
#else
    rob45(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("45,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob46, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob46(structIterations, A);
#else
    rob46(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("46,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob47, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob47(structIterations, A);
#else
    rob47(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("47,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob48, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob48(structIterations, A);
#else
    rob48(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("48,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob49, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob49(structIterations, A);
#else
    rob49(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("49,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob50, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob50(structIterations, A);
#else
    rob50(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("50,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob51, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob51(structIterations, A);
#else
    rob51(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("51,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob52, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob52(structIterations, A);
#else
    rob52(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("52,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob53, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob53(structIterations, A);
#else
    rob53(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("53,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob54, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob54(structIterations, A);
#else
    rob54(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("54,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob55, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob55(structIterations, A);
#else
    rob55(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("55,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob56, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob56(structIterations, A);
#else
    rob56(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("56,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob57, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob57(structIterations, A);
#else
    rob57(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("57,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob58, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob58(structIterations, A);
#else
    rob58(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("58,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob59, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob59(structIterations, A);
#else
    rob59(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("59,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob60, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob60(structIterations, A);
#else
    rob60(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("60,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob61, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob61(structIterations, A);
#else
    rob61(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("61,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob62, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob62(structIterations, A);
#else
    rob62(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("62,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob63, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob63(structIterations, A);
#else
    rob63(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("63,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob64, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob64(structIterations, A);
#else
    rob64(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("64,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob65, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob65(structIterations, A);
#else
    rob65(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("65,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob66, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob66(structIterations, A);
#else
    rob66(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("66,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob67, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob67(structIterations, A);
#else
    rob67(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("67,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob68, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob68(structIterations, A);
#else
    rob68(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("68,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob69, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob69(structIterations, A);
#else
    rob69(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("69,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob70, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob70(structIterations, A);
#else
    rob70(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("70,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob71, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob71(structIterations, A);
#else
    rob71(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("71,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob72, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob72(structIterations, A);
#else
    rob72(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("72,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob73, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob73(structIterations, A);
#else
    rob73(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("73,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob74, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob74(structIterations, A);
#else
    rob74(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("74,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob75, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob75(structIterations, A);
#else
    rob75(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("75,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob76, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob76(structIterations, A);
#else
    rob76(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("76,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob77, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob77(structIterations, A);
#else
    rob77(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("77,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob78, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob78(structIterations, A);
#else
    rob78(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("78,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob79, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob79(structIterations, A);
#else
    rob79(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("79,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob80, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob80(structIterations, A);
#else
    rob80(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("80,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob81, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob81(structIterations, A);
#else
    rob81(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("81,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob82, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob82(structIterations, A);
#else
    rob82(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("82,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob83, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob83(structIterations, A);
#else
    rob83(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("83,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob84, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob84(structIterations, A);
#else
    rob84(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("84,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob85, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob85(structIterations, A);
#else
    rob85(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("85,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob86, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob86(structIterations, A);
#else
    rob86(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("86,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob87, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob87(structIterations, A);
#else
    rob87(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("87,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob88, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob88(structIterations, A);
#else
    rob88(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("88,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob89, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob89(structIterations, A);
#else
    rob89(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("89,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob90, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob90(structIterations, A);
#else
    rob90(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("90,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob91, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob91(structIterations, A);
#else
    rob91(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("91,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob92, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob92(structIterations, A);
#else
    rob92(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("92,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob93, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob93(structIterations, A);
#else
    rob93(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("93,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob94, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob94(structIterations, A);
#else
    rob94(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("94,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob95, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob95(structIterations, A);
#else
    rob95(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("95,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob96, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob96(structIterations, A);
#else
    rob96(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("96,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob97, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob97(structIterations, A);
#else
    rob97(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("97,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob98, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob98(structIterations, A);
#else
    rob98(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("98,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob99, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob99(structIterations, A);
#else
    rob99(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("99,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob100, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob100(structIterations, A);
#else
    rob100(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("100,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob101, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob101(structIterations, A);
#else
    rob101(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("101,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob102, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob102(structIterations, A);
#else
    rob102(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("102,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob103, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob103(structIterations, A);
#else
    rob103(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("103,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob104, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob104(structIterations, A);
#else
    rob104(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("104,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob105, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob105(structIterations, A);
#else
    rob105(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("105,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob106, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob106(structIterations, A);
#else
    rob106(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("106,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob107, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob107(structIterations, A);
#else
    rob107(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("107,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob108, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob108(structIterations, A);
#else
    rob108(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("108,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob109, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob109(structIterations, A);
#else
    rob109(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("109,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob110, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob110(structIterations, A);
#else
    rob110(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("110,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob111, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob111(structIterations, A);
#else
    rob111(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("111,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob112, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob112(structIterations, A);
#else
    rob112(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("112,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob113, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob113(structIterations, A);
#else
    rob113(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("113,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob114, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob114(structIterations, A);
#else
    rob114(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("114,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob115, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob115(structIterations, A);
#else
    rob115(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("115,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob116, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob116(structIterations, A);
#else
    rob116(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("116,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob117, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob117(structIterations, A);
#else
    rob117(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("117,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob118, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob118(structIterations, A);
#else
    rob118(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("118,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob119, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob119(structIterations, A);
#else
    rob119(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("119,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob120, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob120(structIterations, A);
#else
    rob120(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("120,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob121, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob121(structIterations, A);
#else
    rob121(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("121,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob122, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob122(structIterations, A);
#else
    rob122(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("122,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob123, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob123(structIterations, A);
#else
    rob123(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("123,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob124, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob124(structIterations, A);
#else
    rob124(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("124,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob125, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob125(structIterations, A);
#else
    rob125(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("125,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob126, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob126(structIterations, A);
#else
    rob126(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("126,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob127, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob127(structIterations, A);
#else
    rob127(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("127,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob128, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob128(structIterations, A);
#else
    rob128(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("128,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob129, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob129(structIterations, A);
#else
    rob129(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("129,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob130, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob130(structIterations, A);
#else
    rob130(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("130,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob131, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob131(structIterations, A);
#else
    rob131(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("131,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob132, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob132(structIterations, A);
#else
    rob132(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("132,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob133, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob133(structIterations, A);
#else
    rob133(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("133,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob134, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob134(structIterations, A);
#else
    rob134(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("134,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob135, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob135(structIterations, A);
#else
    rob135(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("135,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob136, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob136(structIterations, A);
#else
    rob136(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("136,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob137, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob137(structIterations, A);
#else
    rob137(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("137,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob138, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob138(structIterations, A);
#else
    rob138(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("138,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob139, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob139(structIterations, A);
#else
    rob139(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("139,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob140, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob140(structIterations, A);
#else
    rob140(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("140,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob141, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob141(structIterations, A);
#else
    rob141(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("141,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob142, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob142(structIterations, A);
#else
    rob142(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("142,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob143, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob143(structIterations, A);
#else
    rob143(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("143,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob144, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob144(structIterations, A);
#else
    rob144(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("144,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob145, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob145(structIterations, A);
#else
    rob145(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("145,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob146, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob146(structIterations, A);
#else
    rob146(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("146,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob147, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob147(structIterations, A);
#else
    rob147(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("147,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob148, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob148(structIterations, A);
#else
    rob148(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("148,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob149, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob149(structIterations, A);
#else
    rob149(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("149,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob150, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob150(structIterations, A);
#else
    rob150(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("150,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob151, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob151(structIterations, A);
#else
    rob151(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("151,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob152, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob152(structIterations, A);
#else
    rob152(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("152,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob153, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob153(structIterations, A);
#else
    rob153(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("153,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob154, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob154(structIterations, A);
#else
    rob154(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("154,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob155, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob155(structIterations, A);
#else
    rob155(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("155,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob156, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob156(structIterations, A);
#else
    rob156(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("156,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob157, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob157(structIterations, A);
#else
    rob157(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("157,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob158, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob158(structIterations, A);
#else
    rob158(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("158,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob159, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob159(structIterations, A);
#else
    rob159(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("159,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob160, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob160(structIterations, A);
#else
    rob160(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("160,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob161, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob161(structIterations, A);
#else
    rob161(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("161,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob162, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob162(structIterations, A);
#else
    rob162(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("162,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob163, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob163(structIterations, A);
#else
    rob163(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("163,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob164, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob164(structIterations, A);
#else
    rob164(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("164,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob165, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob165(structIterations, A);
#else
    rob165(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("165,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob166, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob166(structIterations, A);
#else
    rob166(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("166,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob167, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob167(structIterations, A);
#else
    rob167(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("167,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob168, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob168(structIterations, A);
#else
    rob168(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("168,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob169, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob169(structIterations, A);
#else
    rob169(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("169,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob170, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob170(structIterations, A);
#else
    rob170(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("170,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob171, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob171(structIterations, A);
#else
    rob171(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("171,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob172, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob172(structIterations, A);
#else
    rob172(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("172,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob173, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob173(structIterations, A);
#else
    rob173(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("173,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob174, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob174(structIterations, A);
#else
    rob174(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("174,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob175, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob175(structIterations, A);
#else
    rob175(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("175,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob176, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob176(structIterations, A);
#else
    rob176(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("176,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob177, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob177(structIterations, A);
#else
    rob177(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("177,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob178, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob178(structIterations, A);
#else
    rob178(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("178,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob179, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob179(structIterations, A);
#else
    rob179(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("179,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob180, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob180(structIterations, A);
#else
    rob180(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("180,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob181, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob181(structIterations, A);
#else
    rob181(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("181,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob182, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob182(structIterations, A);
#else
    rob182(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("182,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob183, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob183(structIterations, A);
#else
    rob183(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("183,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob184, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob184(structIterations, A);
#else
    rob184(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("184,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob185, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob185(structIterations, A);
#else
    rob185(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("185,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob186, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob186(structIterations, A);
#else
    rob186(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("186,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob187, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob187(structIterations, A);
#else
    rob187(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("187,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob188, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob188(structIterations, A);
#else
    rob188(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("188,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob189, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob189(structIterations, A);
#else
    rob189(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("189,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob190, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob190(structIterations, A);
#else
    rob190(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("190,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob191, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob191(structIterations, A);
#else
    rob191(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("191,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob192, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob192(structIterations, A);
#else
    rob192(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("192,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob193, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob193(structIterations, A);
#else
    rob193(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("193,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob194, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob194(structIterations, A);
#else
    rob194(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("194,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob195, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob195(structIterations, A);
#else
    rob195(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("195,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob196, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob196(structIterations, A);
#else
    rob196(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("196,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob197, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob197(structIterations, A);
#else
    rob197(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("197,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob198, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob198(structIterations, A);
#else
    rob198(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("198,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob199, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob199(structIterations, A);
#else
    rob199(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("199,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob200, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob200(structIterations, A);
#else
    rob200(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("200,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob201, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob201(structIterations, A);
#else
    rob201(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("201,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob202, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob202(structIterations, A);
#else
    rob202(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("202,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob203, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob203(structIterations, A);
#else
    rob203(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("203,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob204, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob204(structIterations, A);
#else
    rob204(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("204,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob205, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob205(structIterations, A);
#else
    rob205(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("205,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob206, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob206(structIterations, A);
#else
    rob206(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("206,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob207, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob207(structIterations, A);
#else
    rob207(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("207,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob208, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob208(structIterations, A);
#else
    rob208(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("208,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob209, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob209(structIterations, A);
#else
    rob209(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("209,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob210, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob210(structIterations, A);
#else
    rob210(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("210,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob211, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob211(structIterations, A);
#else
    rob211(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("211,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob212, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob212(structIterations, A);
#else
    rob212(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("212,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob213, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob213(structIterations, A);
#else
    rob213(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("213,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob214, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob214(structIterations, A);
#else
    rob214(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("214,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob215, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob215(structIterations, A);
#else
    rob215(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("215,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob216, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob216(structIterations, A);
#else
    rob216(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("216,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob217, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob217(structIterations, A);
#else
    rob217(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("217,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob218, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob218(structIterations, A);
#else
    rob218(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("218,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob219, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob219(structIterations, A);
#else
    rob219(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("219,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob220, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob220(structIterations, A);
#else
    rob220(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("220,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob221, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob221(structIterations, A);
#else
    rob221(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("221,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob222, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob222(structIterations, A);
#else
    rob222(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("222,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob223, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob223(structIterations, A);
#else
    rob223(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("223,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob224, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob224(structIterations, A);
#else
    rob224(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("224,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob225, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob225(structIterations, A);
#else
    rob225(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("225,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob226, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob226(structIterations, A);
#else
    rob226(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("226,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob227, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob227(structIterations, A);
#else
    rob227(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("227,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob228, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob228(structIterations, A);
#else
    rob228(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("228,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob229, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob229(structIterations, A);
#else
    rob229(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("229,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob230, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob230(structIterations, A);
#else
    rob230(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("230,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob231, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob231(structIterations, A);
#else
    rob231(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("231,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob232, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob232(structIterations, A);
#else
    rob232(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("232,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob233, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob233(structIterations, A);
#else
    rob233(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("233,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob234, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob234(structIterations, A);
#else
    rob234(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("234,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob235, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob235(structIterations, A);
#else
    rob235(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("235,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob236, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob236(structIterations, A);
#else
    rob236(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("236,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob237, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob237(structIterations, A);
#else
    rob237(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("237,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob238, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob238(structIterations, A);
#else
    rob238(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("238,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob239, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob239(structIterations, A);
#else
    rob239(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("239,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob240, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob240(structIterations, A);
#else
    rob240(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("240,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob241, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob241(structIterations, A);
#else
    rob241(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("241,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob242, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob242(structIterations, A);
#else
    rob242(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("242,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob243, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob243(structIterations, A);
#else
    rob243(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("243,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob244, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob244(structIterations, A);
#else
    rob244(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("244,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob245, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob245(structIterations, A);
#else
    rob245(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("245,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob246, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob246(structIterations, A);
#else
    rob246(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("246,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob247, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob247(structIterations, A);
#else
    rob247(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("247,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob248, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob248(structIterations, A);
#else
    rob248(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("248,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob249, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob249(structIterations, A);
#else
    rob249(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("249,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob250, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob250(structIterations, A);
#else
    rob250(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("250,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob251, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob251(structIterations, A);
#else
    rob251(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("251,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob252, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob252(structIterations, A);
#else
    rob252(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("252,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob253, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob253(structIterations, A);
#else
    rob253(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("253,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob254, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob254(structIterations, A);
#else
    rob254(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("254,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob255, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob255(structIterations, A);
#else
    rob255(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("255,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob256, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob256(structIterations, A);
#else
    rob256(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("256,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob257, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob257(structIterations, A);
#else
    rob257(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("257,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob258, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob258(structIterations, A);
#else
    rob258(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("258,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob259, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob259(structIterations, A);
#else
    rob259(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("259,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob260, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob260(structIterations, A);
#else
    rob260(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("260,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob261, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob261(structIterations, A);
#else
    rob261(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("261,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob262, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob262(structIterations, A);
#else
    rob262(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("262,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob263, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob263(structIterations, A);
#else
    rob263(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("263,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob264, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob264(structIterations, A);
#else
    rob264(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("264,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob265, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob265(structIterations, A);
#else
    rob265(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("265,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob266, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob266(structIterations, A);
#else
    rob266(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("266,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob267, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob267(structIterations, A);
#else
    rob267(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("267,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob268, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob268(structIterations, A);
#else
    rob268(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("268,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob269, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob269(structIterations, A);
#else
    rob269(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("269,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob270, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob270(structIterations, A);
#else
    rob270(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("270,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob271, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob271(structIterations, A);
#else
    rob271(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("271,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob272, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob272(structIterations, A);
#else
    rob272(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("272,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob273, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob273(structIterations, A);
#else
    rob273(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("273,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob274, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob274(structIterations, A);
#else
    rob274(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("274,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob275, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob275(structIterations, A);
#else
    rob275(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("275,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob276, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob276(structIterations, A);
#else
    rob276(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("276,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob277, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob277(structIterations, A);
#else
    rob277(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("277,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob278, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob278(structIterations, A);
#else
    rob278(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("278,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob279, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob279(structIterations, A);
#else
    rob279(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("279,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob280, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob280(structIterations, A);
#else
    rob280(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("280,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob281, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob281(structIterations, A);
#else
    rob281(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("281,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob282, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob282(structIterations, A);
#else
    rob282(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("282,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob283, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob283(structIterations, A);
#else
    rob283(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("283,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob284, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob284(structIterations, A);
#else
    rob284(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("284,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob285, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob285(structIterations, A);
#else
    rob285(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("285,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob286, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob286(structIterations, A);
#else
    rob286(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("286,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob287, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob287(structIterations, A);
#else
    rob287(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("287,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob288, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob288(structIterations, A);
#else
    rob288(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("288,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob289, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob289(structIterations, A);
#else
    rob289(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("289,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob290, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob290(structIterations, A);
#else
    rob290(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("290,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob291, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob291(structIterations, A);
#else
    rob291(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("291,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob292, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob292(structIterations, A);
#else
    rob292(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("292,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob293, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob293(structIterations, A);
#else
    rob293(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("293,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob294, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob294(structIterations, A);
#else
    rob294(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("294,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob295, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob295(structIterations, A);
#else
    rob295(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("295,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob296, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob296(structIterations, A);
#else
    rob296(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("296,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob297, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob297(structIterations, A);
#else
    rob297(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("297,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob298, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob298(structIterations, A);
#else
    rob298(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("298,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob299, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob299(structIterations, A);
#else
    rob299(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("299,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob300, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob300(structIterations, A);
#else
    rob300(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("300,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob301, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob301(structIterations, A);
#else
    rob301(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("301,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob302, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob302(structIterations, A);
#else
    rob302(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("302,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob303, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob303(structIterations, A);
#else
    rob303(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("303,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob304, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob304(structIterations, A);
#else
    rob304(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("304,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob305, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob305(structIterations, A);
#else
    rob305(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("305,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob306, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob306(structIterations, A);
#else
    rob306(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("306,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob307, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob307(structIterations, A);
#else
    rob307(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("307,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob308, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob308(structIterations, A);
#else
    rob308(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("308,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob309, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob309(structIterations, A);
#else
    rob309(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("309,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob310, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob310(structIterations, A);
#else
    rob310(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("310,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob311, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob311(structIterations, A);
#else
    rob311(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("311,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob312, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob312(structIterations, A);
#else
    rob312(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("312,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob313, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob313(structIterations, A);
#else
    rob313(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("313,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob314, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob314(structIterations, A);
#else
    rob314(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("314,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob315, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob315(structIterations, A);
#else
    rob315(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("315,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob316, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob316(structIterations, A);
#else
    rob316(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("316,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob317, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob317(structIterations, A);
#else
    rob317(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("317,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob318, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob318(structIterations, A);
#else
    rob318(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("318,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob319, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob319(structIterations, A);
#else
    rob319(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("319,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob320, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob320(structIterations, A);
#else
    rob320(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("320,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob321, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob321(structIterations, A);
#else
    rob321(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("321,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob322, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob322(structIterations, A);
#else
    rob322(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("322,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob323, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob323(structIterations, A);
#else
    rob323(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("323,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob324, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob324(structIterations, A);
#else
    rob324(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("324,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob325, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob325(structIterations, A);
#else
    rob325(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("325,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob326, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob326(structIterations, A);
#else
    rob326(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("326,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob327, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob327(structIterations, A);
#else
    rob327(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("327,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob328, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob328(structIterations, A);
#else
    rob328(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("328,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob329, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob329(structIterations, A);
#else
    rob329(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("329,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob330, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob330(structIterations, A);
#else
    rob330(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("330,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob331, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob331(structIterations, A);
#else
    rob331(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("331,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob332, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob332(structIterations, A);
#else
    rob332(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("332,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob333, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob333(structIterations, A);
#else
    rob333(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("333,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob334, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob334(structIterations, A);
#else
    rob334(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("334,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob335, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob335(structIterations, A);
#else
    rob335(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("335,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob336, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob336(structIterations, A);
#else
    rob336(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("336,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob337, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob337(structIterations, A);
#else
    rob337(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("337,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob338, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob338(structIterations, A);
#else
    rob338(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("338,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob339, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob339(structIterations, A);
#else
    rob339(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("339,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob340, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob340(structIterations, A);
#else
    rob340(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("340,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob341, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob341(structIterations, A);
#else
    rob341(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("341,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob342, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob342(structIterations, A);
#else
    rob342(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("342,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob343, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob343(structIterations, A);
#else
    rob343(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("343,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob344, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob344(structIterations, A);
#else
    rob344(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("344,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob345, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob345(structIterations, A);
#else
    rob345(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("345,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob346, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob346(structIterations, A);
#else
    rob346(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("346,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob347, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob347(structIterations, A);
#else
    rob347(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("347,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob348, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob348(structIterations, A);
#else
    rob348(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("348,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob349, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob349(structIterations, A);
#else
    rob349(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("349,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob350, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob350(structIterations, A);
#else
    rob350(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("350,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob351, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob351(structIterations, A);
#else
    rob351(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("351,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob352, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob352(structIterations, A);
#else
    rob352(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("352,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob353, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob353(structIterations, A);
#else
    rob353(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("353,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob354, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob354(structIterations, A);
#else
    rob354(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("354,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob355, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob355(structIterations, A);
#else
    rob355(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("355,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob356, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob356(structIterations, A);
#else
    rob356(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("356,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob357, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob357(structIterations, A);
#else
    rob357(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("357,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob358, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob358(structIterations, A);
#else
    rob358(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("358,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob359, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob359(structIterations, A);
#else
    rob359(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("359,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob360, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob360(structIterations, A);
#else
    rob360(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("360,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob361, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob361(structIterations, A);
#else
    rob361(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("361,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob362, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob362(structIterations, A);
#else
    rob362(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("362,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob363, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob363(structIterations, A);
#else
    rob363(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("363,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob364, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob364(structIterations, A);
#else
    rob364(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("364,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob365, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob365(structIterations, A);
#else
    rob365(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("365,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob366, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob366(structIterations, A);
#else
    rob366(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("366,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob367, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob367(structIterations, A);
#else
    rob367(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("367,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob368, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob368(structIterations, A);
#else
    rob368(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("368,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob369, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob369(structIterations, A);
#else
    rob369(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("369,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob370, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob370(structIterations, A);
#else
    rob370(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("370,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob371, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob371(structIterations, A);
#else
    rob371(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("371,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob372, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob372(structIterations, A);
#else
    rob372(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("372,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob373, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob373(structIterations, A);
#else
    rob373(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("373,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob374, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob374(structIterations, A);
#else
    rob374(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("374,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob375, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob375(structIterations, A);
#else
    rob375(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("375,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob376, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob376(structIterations, A);
#else
    rob376(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("376,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob377, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob377(structIterations, A);
#else
    rob377(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("377,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob378, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob378(structIterations, A);
#else
    rob378(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("378,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob379, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob379(structIterations, A);
#else
    rob379(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("379,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob380, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob380(structIterations, A);
#else
    rob380(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("380,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob381, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob381(structIterations, A);
#else
    rob381(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("381,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob382, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob382(structIterations, A);
#else
    rob382(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("382,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob383, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob383(structIterations, A);
#else
    rob383(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("383,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob384, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob384(structIterations, A);
#else
    rob384(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("384,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob385, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob385(structIterations, A);
#else
    rob385(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("385,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob386, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob386(structIterations, A);
#else
    rob386(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("386,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob387, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob387(structIterations, A);
#else
    rob387(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("387,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob388, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob388(structIterations, A);
#else
    rob388(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("388,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob389, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob389(structIterations, A);
#else
    rob389(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("389,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob390, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob390(structIterations, A);
#else
    rob390(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("390,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob391, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob391(structIterations, A);
#else
    rob391(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("391,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob392, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob392(structIterations, A);
#else
    rob392(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("392,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob393, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob393(structIterations, A);
#else
    rob393(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("393,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob394, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob394(structIterations, A);
#else
    rob394(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("394,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob395, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob395(structIterations, A);
#else
    rob395(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("395,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob396, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob396(structIterations, A);
#else
    rob396(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("396,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob397, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob397(structIterations, A);
#else
    rob397(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("397,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob398, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob398(structIterations, A);
#else
    rob398(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("398,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob399, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob399(structIterations, A);
#else
    rob399(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("399,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob400, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob400(structIterations, A);
#else
    rob400(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("400,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob401, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob401(structIterations, A);
#else
    rob401(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("401,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob402, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob402(structIterations, A);
#else
    rob402(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("402,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob403, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob403(structIterations, A);
#else
    rob403(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("403,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob404, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob404(structIterations, A);
#else
    rob404(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("404,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob405, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob405(structIterations, A);
#else
    rob405(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("405,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob406, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob406(structIterations, A);
#else
    rob406(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("406,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob407, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob407(structIterations, A);
#else
    rob407(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("407,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob408, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob408(structIterations, A);
#else
    rob408(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("408,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob409, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob409(structIterations, A);
#else
    rob409(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("409,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob410, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob410(structIterations, A);
#else
    rob410(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("410,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob411, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob411(structIterations, A);
#else
    rob411(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("411,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob412, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob412(structIterations, A);
#else
    rob412(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("412,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob413, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob413(structIterations, A);
#else
    rob413(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("413,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob414, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob414(structIterations, A);
#else
    rob414(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("414,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob415, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob415(structIterations, A);
#else
    rob415(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("415,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob416, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob416(structIterations, A);
#else
    rob416(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("416,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob417, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob417(structIterations, A);
#else
    rob417(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("417,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob418, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob418(structIterations, A);
#else
    rob418(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("418,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob419, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob419(structIterations, A);
#else
    rob419(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("419,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob420, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob420(structIterations, A);
#else
    rob420(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("420,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob421, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob421(structIterations, A);
#else
    rob421(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("421,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob422, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob422(structIterations, A);
#else
    rob422(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("422,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob423, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob423(structIterations, A);
#else
    rob423(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("423,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob424, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob424(structIterations, A);
#else
    rob424(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("424,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob425, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob425(structIterations, A);
#else
    rob425(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("425,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob426, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob426(structIterations, A);
#else
    rob426(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("426,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob427, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob427(structIterations, A);
#else
    rob427(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("427,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob428, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob428(structIterations, A);
#else
    rob428(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("428,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob429, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob429(structIterations, A);
#else
    rob429(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("429,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob430, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob430(structIterations, A);
#else
    rob430(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("430,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob431, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob431(structIterations, A);
#else
    rob431(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("431,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob432, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob432(structIterations, A);
#else
    rob432(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("432,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob433, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob433(structIterations, A);
#else
    rob433(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("433,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob434, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob434(structIterations, A);
#else
    rob434(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("434,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob435, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob435(structIterations, A);
#else
    rob435(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("435,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob436, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob436(structIterations, A);
#else
    rob436(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("436,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob437, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob437(structIterations, A);
#else
    rob437(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("437,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob438, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob438(structIterations, A);
#else
    rob438(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("438,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob439, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob439(structIterations, A);
#else
    rob439(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("439,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob440, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob440(structIterations, A);
#else
    rob440(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("440,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob441, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob441(structIterations, A);
#else
    rob441(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("441,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob442, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob442(structIterations, A);
#else
    rob442(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("442,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob443, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob443(structIterations, A);
#else
    rob443(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("443,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob444, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob444(structIterations, A);
#else
    rob444(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("444,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob445, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob445(structIterations, A);
#else
    rob445(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("445,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob446, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob446(structIterations, A);
#else
    rob446(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("446,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob447, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob447(structIterations, A);
#else
    rob447(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("447,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob448, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob448(structIterations, A);
#else
    rob448(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("448,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob449, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob449(structIterations, A);
#else
    rob449(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("449,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob450, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob450(structIterations, A);
#else
    rob450(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("450,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob451, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob451(structIterations, A);
#else
    rob451(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("451,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob452, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob452(structIterations, A);
#else
    rob452(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("452,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob453, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob453(structIterations, A);
#else
    rob453(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("453,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob454, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob454(structIterations, A);
#else
    rob454(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("454,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob455, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob455(structIterations, A);
#else
    rob455(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("455,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob456, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob456(structIterations, A);
#else
    rob456(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("456,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob457, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob457(structIterations, A);
#else
    rob457(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("457,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob458, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob458(structIterations, A);
#else
    rob458(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("458,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob459, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob459(structIterations, A);
#else
    rob459(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("459,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob460, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob460(structIterations, A);
#else
    rob460(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("460,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob461, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob461(structIterations, A);
#else
    rob461(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("461,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob462, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob462(structIterations, A);
#else
    rob462(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("462,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob463, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob463(structIterations, A);
#else
    rob463(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("463,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob464, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob464(structIterations, A);
#else
    rob464(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("464,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob465, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob465(structIterations, A);
#else
    rob465(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("465,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob466, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob466(structIterations, A);
#else
    rob466(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("466,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob467, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob467(structIterations, A);
#else
    rob467(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("467,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob468, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob468(structIterations, A);
#else
    rob468(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("468,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob469, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob469(structIterations, A);
#else
    rob469(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("469,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob470, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob470(structIterations, A);
#else
    rob470(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("470,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob471, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob471(structIterations, A);
#else
    rob471(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("471,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob472, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob472(structIterations, A);
#else
    rob472(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("472,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob473, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob473(structIterations, A);
#else
    rob473(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("473,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob474, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob474(structIterations, A);
#else
    rob474(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("474,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob475, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob475(structIterations, A);
#else
    rob475(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("475,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob476, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob476(structIterations, A);
#else
    rob476(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("476,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob477, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob477(structIterations, A);
#else
    rob477(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("477,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob478, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob478(structIterations, A);
#else
    rob478(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("478,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob479, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob479(structIterations, A);
#else
    rob479(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("479,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob480, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob480(structIterations, A);
#else
    rob480(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("480,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob481, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob481(structIterations, A);
#else
    rob481(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("481,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob482, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob482(structIterations, A);
#else
    rob482(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("482,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob483, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob483(structIterations, A);
#else
    rob483(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("483,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob484, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob484(structIterations, A);
#else
    rob484(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("484,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob485, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob485(structIterations, A);
#else
    rob485(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("485,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob486, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob486(structIterations, A);
#else
    rob486(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("486,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob487, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob487(structIterations, A);
#else
    rob487(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("487,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob488, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob488(structIterations, A);
#else
    rob488(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("488,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob489, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob489(structIterations, A);
#else
    rob489(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("489,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob490, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob490(structIterations, A);
#else
    rob490(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("490,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob491, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob491(structIterations, A);
#else
    rob491(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("491,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob492, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob492(structIterations, A);
#else
    rob492(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("492,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob493, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob493(structIterations, A);
#else
    rob493(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("493,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob494, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob494(structIterations, A);
#else
    rob494(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("494,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob495, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob495(structIterations, A);
#else
    rob495(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("495,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob496, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob496(structIterations, A);
#else
    rob496(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("496,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob497, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob497(structIterations, A);
#else
    rob497(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("497,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob498, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob498(structIterations, A);
#else
    rob498(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("498,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob499, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob499(structIterations, A);
#else
    rob499(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("499,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob500, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob500(structIterations, A);
#else
    rob500(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("500,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob501, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob501(structIterations, A);
#else
    rob501(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("501,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob502, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob502(structIterations, A);
#else
    rob502(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("502,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob503, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob503(structIterations, A);
#else
    rob503(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("503,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob504, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob504(structIterations, A);
#else
    rob504(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("504,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob505, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob505(structIterations, A);
#else
    rob505(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("505,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob506, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob506(structIterations, A);
#else
    rob506(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("506,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob507, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob507(structIterations, A);
#else
    rob507(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("507,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob508, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob508(structIterations, A);
#else
    rob508(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("508,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob509, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob509(structIterations, A);
#else
    rob509(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("509,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob510, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob510(structIterations, A);
#else
    rob510(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("510,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob511, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob511(structIterations, A);
#else
    rob511(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("511,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob512, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob512(structIterations, A);
#else
    rob512(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("512,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob513, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob513(structIterations, A);
#else
    rob513(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("513,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob514, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob514(structIterations, A);
#else
    rob514(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("514,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob515, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob515(structIterations, A);
#else
    rob515(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("515,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob516, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob516(structIterations, A);
#else
    rob516(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("516,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob517, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob517(structIterations, A);
#else
    rob517(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("517,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob518, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob518(structIterations, A);
#else
    rob518(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("518,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob519, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob519(structIterations, A);
#else
    rob519(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("519,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob520, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob520(structIterations, A);
#else
    rob520(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("520,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob521, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob521(structIterations, A);
#else
    rob521(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("521,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob522, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob522(structIterations, A);
#else
    rob522(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("522,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob523, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob523(structIterations, A);
#else
    rob523(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("523,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob524, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob524(structIterations, A);
#else
    rob524(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("524,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob525, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob525(structIterations, A);
#else
    rob525(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("525,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob526, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob526(structIterations, A);
#else
    rob526(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("526,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob527, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob527(structIterations, A);
#else
    rob527(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("527,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob528, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob528(structIterations, A);
#else
    rob528(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("528,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob529, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob529(structIterations, A);
#else
    rob529(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("529,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob530, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob530(structIterations, A);
#else
    rob530(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("530,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob531, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob531(structIterations, A);
#else
    rob531(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("531,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob532, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob532(structIterations, A);
#else
    rob532(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("532,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob533, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob533(structIterations, A);
#else
    rob533(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("533,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob534, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob534(structIterations, A);
#else
    rob534(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("534,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob535, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob535(structIterations, A);
#else
    rob535(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("535,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob536, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob536(structIterations, A);
#else
    rob536(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("536,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob537, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob537(structIterations, A);
#else
    rob537(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("537,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob538, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob538(structIterations, A);
#else
    rob538(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("538,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob539, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob539(structIterations, A);
#else
    rob539(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("539,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob540, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob540(structIterations, A);
#else
    rob540(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("540,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob541, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob541(structIterations, A);
#else
    rob541(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("541,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob542, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob542(structIterations, A);
#else
    rob542(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("542,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob543, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob543(structIterations, A);
#else
    rob543(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("543,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob544, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob544(structIterations, A);
#else
    rob544(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("544,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob545, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob545(structIterations, A);
#else
    rob545(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("545,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob546, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob546(structIterations, A);
#else
    rob546(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("546,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob547, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob547(structIterations, A);
#else
    rob547(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("547,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob548, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob548(structIterations, A);
#else
    rob548(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("548,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob549, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob549(structIterations, A);
#else
    rob549(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("549,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob550, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob550(structIterations, A);
#else
    rob550(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("550,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob551, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob551(structIterations, A);
#else
    rob551(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("551,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob552, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob552(structIterations, A);
#else
    rob552(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("552,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob553, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob553(structIterations, A);
#else
    rob553(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("553,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob554, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob554(structIterations, A);
#else
    rob554(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("554,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob555, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob555(structIterations, A);
#else
    rob555(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("555,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob556, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob556(structIterations, A);
#else
    rob556(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("556,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob557, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob557(structIterations, A);
#else
    rob557(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("557,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob558, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob558(structIterations, A);
#else
    rob558(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("558,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob559, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob559(structIterations, A);
#else
    rob559(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("559,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob560, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob560(structIterations, A);
#else
    rob560(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("560,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob561, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob561(structIterations, A);
#else
    rob561(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("561,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob562, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob562(structIterations, A);
#else
    rob562(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("562,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob563, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob563(structIterations, A);
#else
    rob563(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("563,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob564, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob564(structIterations, A);
#else
    rob564(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("564,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob565, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob565(structIterations, A);
#else
    rob565(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("565,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob566, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob566(structIterations, A);
#else
    rob566(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("566,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob567, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob567(structIterations, A);
#else
    rob567(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("567,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob568, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob568(structIterations, A);
#else
    rob568(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("568,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob569, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob569(structIterations, A);
#else
    rob569(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("569,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob570, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob570(structIterations, A);
#else
    rob570(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("570,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob571, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob571(structIterations, A);
#else
    rob571(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("571,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob572, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob572(structIterations, A);
#else
    rob572(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("572,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob573, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob573(structIterations, A);
#else
    rob573(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("573,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob574, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob574(structIterations, A);
#else
    rob574(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("574,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob575, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob575(structIterations, A);
#else
    rob575(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("575,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob576, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob576(structIterations, A);
#else
    rob576(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("576,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob577, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob577(structIterations, A);
#else
    rob577(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("577,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob578, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob578(structIterations, A);
#else
    rob578(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("578,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob579, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob579(structIterations, A);
#else
    rob579(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("579,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob580, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob580(structIterations, A);
#else
    rob580(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("580,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob581, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob581(structIterations, A);
#else
    rob581(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("581,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob582, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob582(structIterations, A);
#else
    rob582(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("582,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob583, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob583(structIterations, A);
#else
    rob583(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("583,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob584, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob584(structIterations, A);
#else
    rob584(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("584,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob585, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob585(structIterations, A);
#else
    rob585(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("585,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob586, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob586(structIterations, A);
#else
    rob586(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("586,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob587, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob587(structIterations, A);
#else
    rob587(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("587,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob588, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob588(structIterations, A);
#else
    rob588(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("588,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob589, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob589(structIterations, A);
#else
    rob589(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("589,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob590, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob590(structIterations, A);
#else
    rob590(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("590,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob591, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob591(structIterations, A);
#else
    rob591(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("591,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob592, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob592(structIterations, A);
#else
    rob592(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("592,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob593, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob593(structIterations, A);
#else
    rob593(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("593,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob594, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob594(structIterations, A);
#else
    rob594(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("594,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob595, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob595(structIterations, A);
#else
    rob595(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("595,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob596, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob596(structIterations, A);
#else
    rob596(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("596,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob597, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob597(structIterations, A);
#else
    rob597(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("597,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob598, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob598(structIterations, A);
#else
    rob598(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("598,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob599, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob599(structIterations, A);
#else
    rob599(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("599,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob600, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob600(structIterations, A);
#else
    rob600(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("600,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob601, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob601(structIterations, A);
#else
    rob601(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("601,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob602, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob602(structIterations, A);
#else
    rob602(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("602,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob603, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob603(structIterations, A);
#else
    rob603(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("603,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob604, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob604(structIterations, A);
#else
    rob604(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("604,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob605, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob605(structIterations, A);
#else
    rob605(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("605,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob606, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob606(structIterations, A);
#else
    rob606(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("606,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob607, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob607(structIterations, A);
#else
    rob607(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("607,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob608, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob608(structIterations, A);
#else
    rob608(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("608,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob609, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob609(structIterations, A);
#else
    rob609(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("609,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob610, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob610(structIterations, A);
#else
    rob610(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("610,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob611, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob611(structIterations, A);
#else
    rob611(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("611,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob612, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob612(structIterations, A);
#else
    rob612(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("612,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob613, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob613(structIterations, A);
#else
    rob613(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("613,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob614, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob614(structIterations, A);
#else
    rob614(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("614,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob615, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob615(structIterations, A);
#else
    rob615(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("615,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob616, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob616(structIterations, A);
#else
    rob616(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("616,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob617, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob617(structIterations, A);
#else
    rob617(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("617,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob618, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob618(structIterations, A);
#else
    rob618(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("618,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob619, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob619(structIterations, A);
#else
    rob619(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("619,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob620, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob620(structIterations, A);
#else
    rob620(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("620,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob621, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob621(structIterations, A);
#else
    rob621(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("621,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob622, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob622(structIterations, A);
#else
    rob622(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("622,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob623, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob623(structIterations, A);
#else
    rob623(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("623,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob624, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob624(structIterations, A);
#else
    rob624(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("624,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob625, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob625(structIterations, A);
#else
    rob625(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("625,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob626, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob626(structIterations, A);
#else
    rob626(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("626,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob627, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob627(structIterations, A);
#else
    rob627(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("627,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob628, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob628(structIterations, A);
#else
    rob628(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("628,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob629, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob629(structIterations, A);
#else
    rob629(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("629,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob630, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob630(structIterations, A);
#else
    rob630(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("630,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob631, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob631(structIterations, A);
#else
    rob631(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("631,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob632, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob632(structIterations, A);
#else
    rob632(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("632,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob633, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob633(structIterations, A);
#else
    rob633(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("633,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob634, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob634(structIterations, A);
#else
    rob634(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("634,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob635, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob635(structIterations, A);
#else
    rob635(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("635,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob636, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob636(structIterations, A);
#else
    rob636(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("636,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob637, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob637(structIterations, A);
#else
    rob637(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("637,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob638, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob638(structIterations, A);
#else
    rob638(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("638,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob639, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob639(structIterations, A);
#else
    rob639(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("639,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob640, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob640(structIterations, A);
#else
    rob640(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("640,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob641, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob641(structIterations, A);
#else
    rob641(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("641,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob642, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob642(structIterations, A);
#else
    rob642(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("642,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob643, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob643(structIterations, A);
#else
    rob643(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("643,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob644, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob644(structIterations, A);
#else
    rob644(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("644,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob645, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob645(structIterations, A);
#else
    rob645(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("645,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob646, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob646(structIterations, A);
#else
    rob646(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("646,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob647, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob647(structIterations, A);
#else
    rob647(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("647,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob648, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob648(structIterations, A);
#else
    rob648(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("648,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob649, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob649(structIterations, A);
#else
    rob649(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("649,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob650, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob650(structIterations, A);
#else
    rob650(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("650,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob651, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob651(structIterations, A);
#else
    rob651(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("651,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob652, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob652(structIterations, A);
#else
    rob652(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("652,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob653, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob653(structIterations, A);
#else
    rob653(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("653,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob654, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob654(structIterations, A);
#else
    rob654(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("654,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob655, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob655(structIterations, A);
#else
    rob655(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("655,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob656, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob656(structIterations, A);
#else
    rob656(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("656,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob657, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob657(structIterations, A);
#else
    rob657(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("657,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob658, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob658(structIterations, A);
#else
    rob658(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("658,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob659, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob659(structIterations, A);
#else
    rob659(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("659,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob660, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob660(structIterations, A);
#else
    rob660(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("660,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob661, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob661(structIterations, A);
#else
    rob661(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("661,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob662, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob662(structIterations, A);
#else
    rob662(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("662,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob663, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob663(structIterations, A);
#else
    rob663(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("663,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob664, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob664(structIterations, A);
#else
    rob664(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("664,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob665, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob665(structIterations, A);
#else
    rob665(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("665,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob666, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob666(structIterations, A);
#else
    rob666(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("666,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob667, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob667(structIterations, A);
#else
    rob667(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("667,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob668, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob668(structIterations, A);
#else
    rob668(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("668,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob669, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob669(structIterations, A);
#else
    rob669(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("669,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob670, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob670(structIterations, A);
#else
    rob670(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("670,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob671, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob671(structIterations, A);
#else
    rob671(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("671,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob672, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob672(structIterations, A);
#else
    rob672(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("672,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob673, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob673(structIterations, A);
#else
    rob673(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("673,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob674, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob674(structIterations, A);
#else
    rob674(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("674,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob675, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob675(structIterations, A);
#else
    rob675(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("675,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob676, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob676(structIterations, A);
#else
    rob676(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("676,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob677, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob677(structIterations, A);
#else
    rob677(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("677,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob678, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob678(structIterations, A);
#else
    rob678(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("678,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob679, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob679(structIterations, A);
#else
    rob679(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("679,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob680, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob680(structIterations, A);
#else
    rob680(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("680,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob681, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob681(structIterations, A);
#else
    rob681(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("681,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob682, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob682(structIterations, A);
#else
    rob682(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("682,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob683, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob683(structIterations, A);
#else
    rob683(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("683,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob684, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob684(structIterations, A);
#else
    rob684(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("684,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob685, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob685(structIterations, A);
#else
    rob685(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("685,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob686, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob686(structIterations, A);
#else
    rob686(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("686,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob687, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob687(structIterations, A);
#else
    rob687(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("687,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob688, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob688(structIterations, A);
#else
    rob688(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("688,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob689, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob689(structIterations, A);
#else
    rob689(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("689,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob690, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob690(structIterations, A);
#else
    rob690(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("690,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob691, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob691(structIterations, A);
#else
    rob691(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("691,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob692, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob692(structIterations, A);
#else
    rob692(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("692,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob693, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob693(structIterations, A);
#else
    rob693(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("693,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob694, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob694(structIterations, A);
#else
    rob694(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("694,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob695, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob695(structIterations, A);
#else
    rob695(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("695,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob696, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob696(structIterations, A);
#else
    rob696(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("696,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob697, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob697(structIterations, A);
#else
    rob697(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("697,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob698, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob698(structIterations, A);
#else
    rob698(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("698,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob699, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob699(structIterations, A);
#else
    rob699(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("699,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob700, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob700(structIterations, A);
#else
    rob700(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("700,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob701, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob701(structIterations, A);
#else
    rob701(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("701,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob702, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob702(structIterations, A);
#else
    rob702(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("702,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob703, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob703(structIterations, A);
#else
    rob703(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("703,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob704, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob704(structIterations, A);
#else
    rob704(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("704,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob705, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob705(structIterations, A);
#else
    rob705(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("705,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob706, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob706(structIterations, A);
#else
    rob706(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("706,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob707, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob707(structIterations, A);
#else
    rob707(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("707,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob708, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob708(structIterations, A);
#else
    rob708(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("708,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob709, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob709(structIterations, A);
#else
    rob709(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("709,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob710, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob710(structIterations, A);
#else
    rob710(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("710,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob711, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob711(structIterations, A);
#else
    rob711(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("711,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob712, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob712(structIterations, A);
#else
    rob712(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("712,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob713, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob713(structIterations, A);
#else
    rob713(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("713,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob714, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob714(structIterations, A);
#else
    rob714(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("714,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob715, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob715(structIterations, A);
#else
    rob715(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("715,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob716, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob716(structIterations, A);
#else
    rob716(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("716,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob717, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob717(structIterations, A);
#else
    rob717(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("717,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob718, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob718(structIterations, A);
#else
    rob718(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("718,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob719, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob719(structIterations, A);
#else
    rob719(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("719,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob720, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob720(structIterations, A);
#else
    rob720(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("720,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob721, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob721(structIterations, A);
#else
    rob721(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("721,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob722, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob722(structIterations, A);
#else
    rob722(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("722,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob723, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob723(structIterations, A);
#else
    rob723(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("723,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob724, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob724(structIterations, A);
#else
    rob724(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("724,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob725, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob725(structIterations, A);
#else
    rob725(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("725,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob726, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob726(structIterations, A);
#else
    rob726(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("726,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob727, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob727(structIterations, A);
#else
    rob727(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("727,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob728, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob728(structIterations, A);
#else
    rob728(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("728,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob729, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob729(structIterations, A);
#else
    rob729(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("729,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob730, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob730(structIterations, A);
#else
    rob730(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("730,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob731, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob731(structIterations, A);
#else
    rob731(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("731,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob732, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob732(structIterations, A);
#else
    rob732(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("732,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob733, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob733(structIterations, A);
#else
    rob733(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("733,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob734, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob734(structIterations, A);
#else
    rob734(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("734,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob735, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob735(structIterations, A);
#else
    rob735(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("735,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob736, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob736(structIterations, A);
#else
    rob736(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("736,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob737, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob737(structIterations, A);
#else
    rob737(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("737,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob738, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob738(structIterations, A);
#else
    rob738(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("738,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob739, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob739(structIterations, A);
#else
    rob739(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("739,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob740, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob740(structIterations, A);
#else
    rob740(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("740,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob741, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob741(structIterations, A);
#else
    rob741(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("741,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob742, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob742(structIterations, A);
#else
    rob742(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("742,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob743, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob743(structIterations, A);
#else
    rob743(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("743,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob744, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob744(structIterations, A);
#else
    rob744(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("744,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob745, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob745(structIterations, A);
#else
    rob745(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("745,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob746, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob746(structIterations, A);
#else
    rob746(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("746,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob747, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob747(structIterations, A);
#else
    rob747(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("747,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob748, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob748(structIterations, A);
#else
    rob748(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("748,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob749, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob749(structIterations, A);
#else
    rob749(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("749,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob750, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob750(structIterations, A);
#else
    rob750(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("750,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob751, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob751(structIterations, A);
#else
    rob751(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("751,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob752, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob752(structIterations, A);
#else
    rob752(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("752,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob753, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob753(structIterations, A);
#else
    rob753(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("753,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob754, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob754(structIterations, A);
#else
    rob754(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("754,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob755, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob755(structIterations, A);
#else
    rob755(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("755,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob756, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob756(structIterations, A);
#else
    rob756(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("756,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob757, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob757(structIterations, A);
#else
    rob757(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("757,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob758, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob758(structIterations, A);
#else
    rob758(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("758,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob759, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob759(structIterations, A);
#else
    rob759(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("759,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob760, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob760(structIterations, A);
#else
    rob760(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("760,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob761, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob761(structIterations, A);
#else
    rob761(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("761,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob762, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob762(structIterations, A);
#else
    rob762(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("762,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob763, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob763(structIterations, A);
#else
    rob763(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("763,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob764, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob764(structIterations, A);
#else
    rob764(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("764,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob765, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob765(structIterations, A);
#else
    rob765(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("765,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob766, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob766(structIterations, A);
#else
    rob766(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("766,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob767, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob767(structIterations, A);
#else
    rob767(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("767,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob768, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob768(structIterations, A);
#else
    rob768(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("768,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob769, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob769(structIterations, A);
#else
    rob769(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("769,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob770, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob770(structIterations, A);
#else
    rob770(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("770,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob771, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob771(structIterations, A);
#else
    rob771(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("771,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob772, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob772(structIterations, A);
#else
    rob772(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("772,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob773, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob773(structIterations, A);
#else
    rob773(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("773,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob774, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob774(structIterations, A);
#else
    rob774(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("774,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob775, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob775(structIterations, A);
#else
    rob775(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("775,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob776, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob776(structIterations, A);
#else
    rob776(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("776,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob777, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob777(structIterations, A);
#else
    rob777(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("777,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob778, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob778(structIterations, A);
#else
    rob778(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("778,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob779, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob779(structIterations, A);
#else
    rob779(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("779,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob780, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob780(structIterations, A);
#else
    rob780(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("780,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob781, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob781(structIterations, A);
#else
    rob781(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("781,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob782, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob782(structIterations, A);
#else
    rob782(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("782,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob783, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob783(structIterations, A);
#else
    rob783(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("783,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob784, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob784(structIterations, A);
#else
    rob784(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("784,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob785, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob785(structIterations, A);
#else
    rob785(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("785,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob786, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob786(structIterations, A);
#else
    rob786(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("786,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob787, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob787(structIterations, A);
#else
    rob787(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("787,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob788, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob788(structIterations, A);
#else
    rob788(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("788,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob789, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob789(structIterations, A);
#else
    rob789(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("789,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob790, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob790(structIterations, A);
#else
    rob790(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("790,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob791, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob791(structIterations, A);
#else
    rob791(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("791,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob792, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob792(structIterations, A);
#else
    rob792(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("792,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob793, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob793(structIterations, A);
#else
    rob793(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("793,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob794, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob794(structIterations, A);
#else
    rob794(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("794,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob795, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob795(structIterations, A);
#else
    rob795(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("795,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob796, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob796(structIterations, A);
#else
    rob796(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("796,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob797, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob797(structIterations, A);
#else
    rob797(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("797,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob798, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob798(structIterations, A);
#else
    rob798(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("798,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob799, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob799(structIterations, A);
#else
    rob799(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("799,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob800, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob800(structIterations, A);
#else
    rob800(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("800,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob801, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob801(structIterations, A);
#else
    rob801(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("801,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob802, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob802(structIterations, A);
#else
    rob802(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("802,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob803, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob803(structIterations, A);
#else
    rob803(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("803,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob804, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob804(structIterations, A);
#else
    rob804(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("804,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob805, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob805(structIterations, A);
#else
    rob805(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("805,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob806, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob806(structIterations, A);
#else
    rob806(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("806,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob807, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob807(structIterations, A);
#else
    rob807(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("807,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob808, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob808(structIterations, A);
#else
    rob808(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("808,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob809, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob809(structIterations, A);
#else
    rob809(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("809,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob810, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob810(structIterations, A);
#else
    rob810(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("810,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob811, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob811(structIterations, A);
#else
    rob811(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("811,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob812, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob812(structIterations, A);
#else
    rob812(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("812,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob813, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob813(structIterations, A);
#else
    rob813(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("813,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob814, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob814(structIterations, A);
#else
    rob814(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("814,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob815, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob815(structIterations, A);
#else
    rob815(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("815,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob816, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob816(structIterations, A);
#else
    rob816(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("816,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob817, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob817(structIterations, A);
#else
    rob817(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("817,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob818, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob818(structIterations, A);
#else
    rob818(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("818,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob819, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob819(structIterations, A);
#else
    rob819(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("819,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob820, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob820(structIterations, A);
#else
    rob820(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("820,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob821, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob821(structIterations, A);
#else
    rob821(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("821,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob822, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob822(structIterations, A);
#else
    rob822(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("822,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob823, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob823(structIterations, A);
#else
    rob823(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("823,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob824, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob824(structIterations, A);
#else
    rob824(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("824,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob825, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob825(structIterations, A);
#else
    rob825(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("825,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob826, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob826(structIterations, A);
#else
    rob826(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("826,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob827, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob827(structIterations, A);
#else
    rob827(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("827,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob828, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob828(structIterations, A);
#else
    rob828(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("828,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob829, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob829(structIterations, A);
#else
    rob829(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("829,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob830, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob830(structIterations, A);
#else
    rob830(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("830,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob831, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob831(structIterations, A);
#else
    rob831(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("831,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob832, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob832(structIterations, A);
#else
    rob832(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("832,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob833, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob833(structIterations, A);
#else
    rob833(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("833,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob834, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob834(structIterations, A);
#else
    rob834(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("834,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob835, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob835(structIterations, A);
#else
    rob835(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("835,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob836, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob836(structIterations, A);
#else
    rob836(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("836,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob837, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob837(structIterations, A);
#else
    rob837(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("837,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob838, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob838(structIterations, A);
#else
    rob838(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("838,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob839, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob839(structIterations, A);
#else
    rob839(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("839,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob840, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob840(structIterations, A);
#else
    rob840(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("840,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob841, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob841(structIterations, A);
#else
    rob841(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("841,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob842, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob842(structIterations, A);
#else
    rob842(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("842,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob843, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob843(structIterations, A);
#else
    rob843(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("843,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob844, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob844(structIterations, A);
#else
    rob844(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("844,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob845, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob845(structIterations, A);
#else
    rob845(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("845,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob846, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob846(structIterations, A);
#else
    rob846(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("846,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob847, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob847(structIterations, A);
#else
    rob847(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("847,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob848, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob848(structIterations, A);
#else
    rob848(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("848,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob849, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob849(structIterations, A);
#else
    rob849(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("849,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob850, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob850(structIterations, A);
#else
    rob850(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("850,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob851, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob851(structIterations, A);
#else
    rob851(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("851,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob852, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob852(structIterations, A);
#else
    rob852(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("852,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob853, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob853(structIterations, A);
#else
    rob853(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("853,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob854, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob854(structIterations, A);
#else
    rob854(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("854,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob855, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob855(structIterations, A);
#else
    rob855(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("855,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob856, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob856(structIterations, A);
#else
    rob856(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("856,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob857, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob857(structIterations, A);
#else
    rob857(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("857,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob858, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob858(structIterations, A);
#else
    rob858(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("858,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob859, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob859(structIterations, A);
#else
    rob859(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("859,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob860, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob860(structIterations, A);
#else
    rob860(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("860,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob861, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob861(structIterations, A);
#else
    rob861(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("861,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob862, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob862(structIterations, A);
#else
    rob862(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("862,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob863, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob863(structIterations, A);
#else
    rob863(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("863,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob864, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob864(structIterations, A);
#else
    rob864(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("864,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob865, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob865(structIterations, A);
#else
    rob865(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("865,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob866, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob866(structIterations, A);
#else
    rob866(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("866,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob867, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob867(structIterations, A);
#else
    rob867(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("867,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob868, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob868(structIterations, A);
#else
    rob868(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("868,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob869, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob869(structIterations, A);
#else
    rob869(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("869,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob870, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob870(structIterations, A);
#else
    rob870(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("870,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob871, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob871(structIterations, A);
#else
    rob871(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("871,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob872, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob872(structIterations, A);
#else
    rob872(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("872,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob873, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob873(structIterations, A);
#else
    rob873(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("873,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob874, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob874(structIterations, A);
#else
    rob874(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("874,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob875, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob875(structIterations, A);
#else
    rob875(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("875,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob876, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob876(structIterations, A);
#else
    rob876(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("876,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob877, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob877(structIterations, A);
#else
    rob877(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("877,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob878, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob878(structIterations, A);
#else
    rob878(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("878,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob879, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob879(structIterations, A);
#else
    rob879(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("879,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob880, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob880(structIterations, A);
#else
    rob880(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("880,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob881, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob881(structIterations, A);
#else
    rob881(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("881,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob882, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob882(structIterations, A);
#else
    rob882(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("882,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob883, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob883(structIterations, A);
#else
    rob883(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("883,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob884, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob884(structIterations, A);
#else
    rob884(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("884,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob885, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob885(structIterations, A);
#else
    rob885(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("885,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob886, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob886(structIterations, A);
#else
    rob886(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("886,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob887, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob887(structIterations, A);
#else
    rob887(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("887,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob888, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob888(structIterations, A);
#else
    rob888(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("888,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob889, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob889(structIterations, A);
#else
    rob889(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("889,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob890, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob890(structIterations, A);
#else
    rob890(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("890,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob891, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob891(structIterations, A);
#else
    rob891(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("891,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob892, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob892(structIterations, A);
#else
    rob892(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("892,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob893, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob893(structIterations, A);
#else
    rob893(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("893,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob894, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob894(structIterations, A);
#else
    rob894(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("894,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob895, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob895(structIterations, A);
#else
    rob895(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("895,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob896, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob896(structIterations, A);
#else
    rob896(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("896,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob897, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob897(structIterations, A);
#else
    rob897(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("897,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob898, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob898(structIterations, A);
#else
    rob898(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("898,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob899, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob899(structIterations, A);
#else
    rob899(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("899,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob900, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob900(structIterations, A);
#else
    rob900(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("900,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob901, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob901(structIterations, A);
#else
    rob901(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("901,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob902, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob902(structIterations, A);
#else
    rob902(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("902,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob903, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob903(structIterations, A);
#else
    rob903(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("903,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob904, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob904(structIterations, A);
#else
    rob904(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("904,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob905, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob905(structIterations, A);
#else
    rob905(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("905,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob906, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob906(structIterations, A);
#else
    rob906(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("906,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob907, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob907(structIterations, A);
#else
    rob907(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("907,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob908, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob908(structIterations, A);
#else
    rob908(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("908,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob909, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob909(structIterations, A);
#else
    rob909(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("909,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob910, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob910(structIterations, A);
#else
    rob910(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("910,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob911, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob911(structIterations, A);
#else
    rob911(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("911,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob912, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob912(structIterations, A);
#else
    rob912(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("912,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob913, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob913(structIterations, A);
#else
    rob913(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("913,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob914, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob914(structIterations, A);
#else
    rob914(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("914,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob915, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob915(structIterations, A);
#else
    rob915(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("915,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob916, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob916(structIterations, A);
#else
    rob916(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("916,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob917, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob917(structIterations, A);
#else
    rob917(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("917,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob918, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob918(structIterations, A);
#else
    rob918(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("918,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob919, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob919(structIterations, A);
#else
    rob919(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("919,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob920, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob920(structIterations, A);
#else
    rob920(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("920,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob921, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob921(structIterations, A);
#else
    rob921(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("921,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob922, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob922(structIterations, A);
#else
    rob922(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("922,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob923, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob923(structIterations, A);
#else
    rob923(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("923,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob924, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob924(structIterations, A);
#else
    rob924(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("924,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob925, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob925(structIterations, A);
#else
    rob925(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("925,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob926, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob926(structIterations, A);
#else
    rob926(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("926,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob927, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob927(structIterations, A);
#else
    rob927(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("927,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob928, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob928(structIterations, A);
#else
    rob928(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("928,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob929, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob929(structIterations, A);
#else
    rob929(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("929,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob930, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob930(structIterations, A);
#else
    rob930(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("930,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob931, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob931(structIterations, A);
#else
    rob931(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("931,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob932, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob932(structIterations, A);
#else
    rob932(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("932,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob933, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob933(structIterations, A);
#else
    rob933(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("933,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob934, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob934(structIterations, A);
#else
    rob934(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("934,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob935, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob935(structIterations, A);
#else
    rob935(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("935,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob936, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob936(structIterations, A);
#else
    rob936(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("936,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob937, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob937(structIterations, A);
#else
    rob937(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("937,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob938, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob938(structIterations, A);
#else
    rob938(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("938,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob939, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob939(structIterations, A);
#else
    rob939(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("939,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob940, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob940(structIterations, A);
#else
    rob940(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("940,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob941, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob941(structIterations, A);
#else
    rob941(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("941,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob942, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob942(structIterations, A);
#else
    rob942(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("942,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob943, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob943(structIterations, A);
#else
    rob943(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("943,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob944, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob944(structIterations, A);
#else
    rob944(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("944,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob945, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob945(structIterations, A);
#else
    rob945(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("945,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob946, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob946(structIterations, A);
#else
    rob946(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("946,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob947, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob947(structIterations, A);
#else
    rob947(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("947,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob948, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob948(structIterations, A);
#else
    rob948(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("948,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob949, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob949(structIterations, A);
#else
    rob949(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("949,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob950, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob950(structIterations, A);
#else
    rob950(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("950,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob951, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob951(structIterations, A);
#else
    rob951(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("951,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob952, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob952(structIterations, A);
#else
    rob952(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("952,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob953, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob953(structIterations, A);
#else
    rob953(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("953,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob954, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob954(structIterations, A);
#else
    rob954(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("954,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob955, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob955(structIterations, A);
#else
    rob955(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("955,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob956, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob956(structIterations, A);
#else
    rob956(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("956,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob957, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob957(structIterations, A);
#else
    rob957(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("957,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob958, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob958(structIterations, A);
#else
    rob958(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("958,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob959, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob959(structIterations, A);
#else
    rob959(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("959,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob960, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob960(structIterations, A);
#else
    rob960(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("960,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob961, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob961(structIterations, A);
#else
    rob961(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("961,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob962, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob962(structIterations, A);
#else
    rob962(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("962,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob963, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob963(structIterations, A);
#else
    rob963(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("963,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob964, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob964(structIterations, A);
#else
    rob964(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("964,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob965, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob965(structIterations, A);
#else
    rob965(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("965,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob966, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob966(structIterations, A);
#else
    rob966(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("966,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob967, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob967(structIterations, A);
#else
    rob967(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("967,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob968, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob968(structIterations, A);
#else
    rob968(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("968,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob969, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob969(structIterations, A);
#else
    rob969(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("969,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob970, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob970(structIterations, A);
#else
    rob970(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("970,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob971, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob971(structIterations, A);
#else
    rob971(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("971,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob972, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob972(structIterations, A);
#else
    rob972(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("972,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob973, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob973(structIterations, A);
#else
    rob973(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("973,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob974, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob974(structIterations, A);
#else
    rob974(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("974,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob975, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob975(structIterations, A);
#else
    rob975(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("975,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob976, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob976(structIterations, A);
#else
    rob976(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("976,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob977, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob977(structIterations, A);
#else
    rob977(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("977,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob978, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob978(structIterations, A);
#else
    rob978(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("978,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob979, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob979(structIterations, A);
#else
    rob979(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("979,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob980, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob980(structIterations, A);
#else
    rob980(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("980,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob981, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob981(structIterations, A);
#else
    rob981(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("981,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob982, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob982(structIterations, A);
#else
    rob982(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("982,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob983, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob983(structIterations, A);
#else
    rob983(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("983,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob984, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob984(structIterations, A);
#else
    rob984(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("984,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob985, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob985(structIterations, A);
#else
    rob985(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("985,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob986, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob986(structIterations, A);
#else
    rob986(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("986,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob987, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob987(structIterations, A);
#else
    rob987(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("987,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob988, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob988(structIterations, A);
#else
    rob988(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("988,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob989, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob989(structIterations, A);
#else
    rob989(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("989,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob990, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob990(structIterations, A);
#else
    rob990(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("990,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob991, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob991(structIterations, A);
#else
    rob991(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("991,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob992, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob992(structIterations, A);
#else
    rob992(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("992,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob993, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob993(structIterations, A);
#else
    rob993(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("993,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob994, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob994(structIterations, A);
#else
    rob994(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("994,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob995, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob995(structIterations, A);
#else
    rob995(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("995,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob996, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob996(structIterations, A);
#else
    rob996(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("996,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob997, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob997(structIterations, A);
#else
    rob997(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("997,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob998, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob998(structIterations, A);
#else
    rob998(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("998,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob999, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob999(structIterations, A);
#else
    rob999(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("999,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1000, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1000(structIterations, A);
#else
    rob1000(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1000,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1001, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1001(structIterations, A);
#else
    rob1001(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1001,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1002, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1002(structIterations, A);
#else
    rob1002(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1002,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1003, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1003(structIterations, A);
#else
    rob1003(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1003,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1004, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1004(structIterations, A);
#else
    rob1004(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1004,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1005, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1005(structIterations, A);
#else
    rob1005(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1005,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1006, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1006(structIterations, A);
#else
    rob1006(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1006,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1007, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1007(structIterations, A);
#else
    rob1007(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1007,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1008, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1008(structIterations, A);
#else
    rob1008(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1008,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1009, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1009(structIterations, A);
#else
    rob1009(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1009,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1010, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1010(structIterations, A);
#else
    rob1010(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1010,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1011, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1011(structIterations, A);
#else
    rob1011(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1011,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1012, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1012(structIterations, A);
#else
    rob1012(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1012,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1013, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1013(structIterations, A);
#else
    rob1013(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1013,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1014, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1014(structIterations, A);
#else
    rob1014(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1014,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1015, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1015(structIterations, A);
#else
    rob1015(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1015,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1016, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1016(structIterations, A);
#else
    rob1016(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1016,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1017, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1017(structIterations, A);
#else
    rob1017(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1017,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1018, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1018(structIterations, A);
#else
    rob1018(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1018,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1019, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1019(structIterations, A);
#else
    rob1019(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1019,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1020, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1020(structIterations, A);
#else
    rob1020(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1020,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1021, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1021(structIterations, A);
#else
    rob1021(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1021,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1022, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1022(structIterations, A);
#else
    rob1022(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1022,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1023, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1023(structIterations, A);
#else
    rob1023(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1023,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_rob1024, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        rob1024(structIterations, A);
#else
    rob1024(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1024,%f\n", latency);

  }

  if (argc > 1 && strncmp(test_name, "zerorob", 7) == 0) {
    printf("Reorder Buffer Test with Zeroing Idioms:\n");
    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob1, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob1(structIterations, A);
#else
    zerorob1(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("1,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob2, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob2(structIterations, A);
#else
    zerorob2(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("2,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob3, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob3(structIterations, A);
#else
    zerorob3(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("3,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob4, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob4(structIterations, A);
#else
    zerorob4(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("4,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob5, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob5(structIterations, A);
#else
    zerorob5(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("5,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob6, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob6(structIterations, A);
#else
    zerorob6(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("6,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob7, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob7(structIterations, A);
#else
    zerorob7(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("7,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob8, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob8(structIterations, A);
#else
    zerorob8(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("8,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob9, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob9(structIterations, A);
#else
    zerorob9(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("9,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob10, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob10(structIterations, A);
#else
    zerorob10(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("10,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob11, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob11(structIterations, A);
#else
    zerorob11(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("11,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob12, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob12(structIterations, A);
#else
    zerorob12(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("12,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob13, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob13(structIterations, A);
#else
    zerorob13(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("13,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob14, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob14(structIterations, A);
#else
    zerorob14(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("14,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob15, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob15(structIterations, A);
#else
    zerorob15(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("15,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob16, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob16(structIterations, A);
#else
    zerorob16(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("16,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob17, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob17(structIterations, A);
#else
    zerorob17(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("17,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob18, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob18(structIterations, A);
#else
    zerorob18(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("18,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob19, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob19(structIterations, A);
#else
    zerorob19(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("19,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob20, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob20(structIterations, A);
#else
    zerorob20(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("20,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob21, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob21(structIterations, A);
#else
    zerorob21(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("21,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob22, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob22(structIterations, A);
#else
    zerorob22(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("22,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob23, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob23(structIterations, A);
#else
    zerorob23(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("23,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob24, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob24(structIterations, A);
#else
    zerorob24(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("24,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob25, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob25(structIterations, A);
#else
    zerorob25(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("25,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob26, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob26(structIterations, A);
#else
    zerorob26(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("26,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob27, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob27(structIterations, A);
#else
    zerorob27(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("27,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob28, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob28(structIterations, A);
#else
    zerorob28(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("28,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob29, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob29(structIterations, A);
#else
    zerorob29(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("29,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob30, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob30(structIterations, A);
#else
    zerorob30(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("30,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob31, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob31(structIterations, A);
#else
    zerorob31(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("31,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob32, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob32(structIterations, A);
#else
    zerorob32(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("32,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob33, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob33(structIterations, A);
#else
    zerorob33(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("33,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob34, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob34(structIterations, A);
#else
    zerorob34(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("34,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob35, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob35(structIterations, A);
#else
    zerorob35(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("35,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob36, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob36(structIterations, A);
#else
    zerorob36(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("36,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob37, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob37(structIterations, A);
#else
    zerorob37(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("37,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob38, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob38(structIterations, A);
#else
    zerorob38(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("38,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob39, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob39(structIterations, A);
#else
    zerorob39(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("39,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob40, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob40(structIterations, A);
#else
    zerorob40(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("40,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob41, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob41(structIterations, A);
#else
    zerorob41(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("41,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob42, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob42(structIterations, A);
#else
    zerorob42(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("42,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob43, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob43(structIterations, A);
#else
    zerorob43(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("43,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob44, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob44(structIterations, A);
#else
    zerorob44(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("44,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob45, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob45(structIterations, A);
#else
    zerorob45(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("45,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob46, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob46(structIterations, A);
#else
    zerorob46(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("46,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob47, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob47(structIterations, A);
#else
    zerorob47(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("47,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob48, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob48(structIterations, A);
#else
    zerorob48(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("48,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob49, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob49(structIterations, A);
#else
    zerorob49(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("49,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob50, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob50(structIterations, A);
#else
    zerorob50(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("50,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob51, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob51(structIterations, A);
#else
    zerorob51(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("51,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob52, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob52(structIterations, A);
#else
    zerorob52(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("52,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob53, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob53(structIterations, A);
#else
    zerorob53(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("53,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob54, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob54(structIterations, A);
#else
    zerorob54(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("54,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob55, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob55(structIterations, A);
#else
    zerorob55(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("55,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob56, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob56(structIterations, A);
#else
    zerorob56(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("56,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob57, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob57(structIterations, A);
#else
    zerorob57(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("57,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob58, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob58(structIterations, A);
#else
    zerorob58(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("58,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob59, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob59(structIterations, A);
#else
    zerorob59(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("59,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob60, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob60(structIterations, A);
#else
    zerorob60(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("60,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob61, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob61(structIterations, A);
#else
    zerorob61(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("61,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob62, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob62(structIterations, A);
#else
    zerorob62(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("62,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob63, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob63(structIterations, A);
#else
    zerorob63(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("63,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob64, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob64(structIterations, A);
#else
    zerorob64(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("64,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob65, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob65(structIterations, A);
#else
    zerorob65(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("65,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob66, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob66(structIterations, A);
#else
    zerorob66(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("66,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob67, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob67(structIterations, A);
#else
    zerorob67(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("67,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob68, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob68(structIterations, A);
#else
    zerorob68(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("68,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob69, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob69(structIterations, A);
#else
    zerorob69(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("69,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob70, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob70(structIterations, A);
#else
    zerorob70(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("70,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob71, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob71(structIterations, A);
#else
    zerorob71(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("71,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob72, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob72(structIterations, A);
#else
    zerorob72(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("72,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob73, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob73(structIterations, A);
#else
    zerorob73(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("73,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob74, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob74(structIterations, A);
#else
    zerorob74(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("74,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob75, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob75(structIterations, A);
#else
    zerorob75(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("75,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob76, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob76(structIterations, A);
#else
    zerorob76(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("76,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob77, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob77(structIterations, A);
#else
    zerorob77(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("77,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob78, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob78(structIterations, A);
#else
    zerorob78(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("78,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob79, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob79(structIterations, A);
#else
    zerorob79(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("79,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob80, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob80(structIterations, A);
#else
    zerorob80(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("80,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob81, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob81(structIterations, A);
#else
    zerorob81(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("81,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob82, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob82(structIterations, A);
#else
    zerorob82(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("82,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob83, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob83(structIterations, A);
#else
    zerorob83(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("83,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob84, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob84(structIterations, A);
#else
    zerorob84(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("84,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob85, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob85(structIterations, A);
#else
    zerorob85(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("85,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob86, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob86(structIterations, A);
#else
    zerorob86(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("86,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob87, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob87(structIterations, A);
#else
    zerorob87(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("87,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob88, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob88(structIterations, A);
#else
    zerorob88(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("88,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob89, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob89(structIterations, A);
#else
    zerorob89(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("89,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob90, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob90(structIterations, A);
#else
    zerorob90(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("90,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob91, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob91(structIterations, A);
#else
    zerorob91(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("91,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob92, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob92(structIterations, A);
#else
    zerorob92(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("92,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob93, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob93(structIterations, A);
#else
    zerorob93(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("93,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob94, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob94(structIterations, A);
#else
    zerorob94(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("94,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob95, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob95(structIterations, A);
#else
    zerorob95(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("95,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob96, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob96(structIterations, A);
#else
    zerorob96(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("96,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob97, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob97(structIterations, A);
#else
    zerorob97(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("97,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob98, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob98(structIterations, A);
#else
    zerorob98(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("98,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob99, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob99(structIterations, A);
#else
    zerorob99(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("99,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob100, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob100(structIterations, A);
#else
    zerorob100(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("100,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob101, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob101(structIterations, A);
#else
    zerorob101(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("101,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob102, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob102(structIterations, A);
#else
    zerorob102(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("102,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob103, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob103(structIterations, A);
#else
    zerorob103(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("103,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob104, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob104(structIterations, A);
#else
    zerorob104(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("104,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob105, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob105(structIterations, A);
#else
    zerorob105(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("105,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob106, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob106(structIterations, A);
#else
    zerorob106(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("106,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob107, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob107(structIterations, A);
#else
    zerorob107(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("107,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob108, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob108(structIterations, A);
#else
    zerorob108(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("108,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob109, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob109(structIterations, A);
#else
    zerorob109(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("109,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob110, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob110(structIterations, A);
#else
    zerorob110(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("110,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob111, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob111(structIterations, A);
#else
    zerorob111(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("111,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob112, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob112(structIterations, A);
#else
    zerorob112(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("112,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob113, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob113(structIterations, A);
#else
    zerorob113(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("113,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob114, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob114(structIterations, A);
#else
    zerorob114(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("114,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob115, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob115(structIterations, A);
#else
    zerorob115(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("115,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob116, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob116(structIterations, A);
#else
    zerorob116(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("116,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob117, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob117(structIterations, A);
#else
    zerorob117(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("117,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob118, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob118(structIterations, A);
#else
    zerorob118(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("118,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob119, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob119(structIterations, A);
#else
    zerorob119(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("119,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob120, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob120(structIterations, A);
#else
    zerorob120(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("120,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob121, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob121(structIterations, A);
#else
    zerorob121(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("121,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob122, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob122(structIterations, A);
#else
    zerorob122(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("122,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob123, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob123(structIterations, A);
#else
    zerorob123(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("123,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob124, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob124(structIterations, A);
#else
    zerorob124(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("124,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob125, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob125(structIterations, A);
#else
    zerorob125(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("125,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob126, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob126(structIterations, A);
#else
    zerorob126(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("126,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob127, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob127(structIterations, A);
#else
    zerorob127(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("127,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob128, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob128(structIterations, A);
#else
    zerorob128(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("128,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob129, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob129(structIterations, A);
#else
    zerorob129(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("129,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob130, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob130(structIterations, A);
#else
    zerorob130(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("130,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob131, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob131(structIterations, A);
#else
    zerorob131(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("131,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob132, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob132(structIterations, A);
#else
    zerorob132(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("132,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob133, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob133(structIterations, A);
#else
    zerorob133(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("133,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob134, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob134(structIterations, A);
#else
    zerorob134(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("134,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob135, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob135(structIterations, A);
#else
    zerorob135(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("135,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob136, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob136(structIterations, A);
#else
    zerorob136(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("136,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob137, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob137(structIterations, A);
#else
    zerorob137(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("137,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob138, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob138(structIterations, A);
#else
    zerorob138(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("138,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob139, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob139(structIterations, A);
#else
    zerorob139(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("139,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob140, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob140(structIterations, A);
#else
    zerorob140(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("140,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob141, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob141(structIterations, A);
#else
    zerorob141(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("141,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob142, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob142(structIterations, A);
#else
    zerorob142(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("142,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob143, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob143(structIterations, A);
#else
    zerorob143(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("143,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob144, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob144(structIterations, A);
#else
    zerorob144(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("144,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob145, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob145(structIterations, A);
#else
    zerorob145(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("145,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob146, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob146(structIterations, A);
#else
    zerorob146(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("146,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob147, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob147(structIterations, A);
#else
    zerorob147(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("147,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob148, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob148(structIterations, A);
#else
    zerorob148(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("148,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob149, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob149(structIterations, A);
#else
    zerorob149(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("149,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob150, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob150(structIterations, A);
#else
    zerorob150(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("150,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob151, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob151(structIterations, A);
#else
    zerorob151(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("151,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob152, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob152(structIterations, A);
#else
    zerorob152(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("152,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob153, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob153(structIterations, A);
#else
    zerorob153(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("153,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob154, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob154(structIterations, A);
#else
    zerorob154(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("154,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob155, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob155(structIterations, A);
#else
    zerorob155(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("155,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob156, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob156(structIterations, A);
#else
    zerorob156(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("156,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob157, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob157(structIterations, A);
#else
    zerorob157(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("157,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob158, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob158(structIterations, A);
#else
    zerorob158(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("158,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob159, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob159(structIterations, A);
#else
    zerorob159(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("159,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob160, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob160(structIterations, A);
#else
    zerorob160(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("160,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob161, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob161(structIterations, A);
#else
    zerorob161(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("161,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob162, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob162(structIterations, A);
#else
    zerorob162(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("162,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob163, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob163(structIterations, A);
#else
    zerorob163(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("163,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob164, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob164(structIterations, A);
#else
    zerorob164(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("164,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob165, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob165(structIterations, A);
#else
    zerorob165(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("165,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob166, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob166(structIterations, A);
#else
    zerorob166(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("166,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob167, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob167(structIterations, A);
#else
    zerorob167(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("167,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob168, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob168(structIterations, A);
#else
    zerorob168(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("168,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob169, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob169(structIterations, A);
#else
    zerorob169(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("169,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob170, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob170(structIterations, A);
#else
    zerorob170(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("170,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob171, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob171(structIterations, A);
#else
    zerorob171(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("171,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob172, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob172(structIterations, A);
#else
    zerorob172(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("172,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob173, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob173(structIterations, A);
#else
    zerorob173(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("173,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob174, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob174(structIterations, A);
#else
    zerorob174(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("174,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob175, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob175(structIterations, A);
#else
    zerorob175(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("175,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob176, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob176(structIterations, A);
#else
    zerorob176(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("176,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob177, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob177(structIterations, A);
#else
    zerorob177(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("177,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob178, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob178(structIterations, A);
#else
    zerorob178(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("178,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob179, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob179(structIterations, A);
#else
    zerorob179(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("179,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob180, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob180(structIterations, A);
#else
    zerorob180(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("180,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob181, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob181(structIterations, A);
#else
    zerorob181(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("181,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob182, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob182(structIterations, A);
#else
    zerorob182(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("182,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob183, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob183(structIterations, A);
#else
    zerorob183(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("183,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob184, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob184(structIterations, A);
#else
    zerorob184(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("184,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob185, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob185(structIterations, A);
#else
    zerorob185(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("185,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob186, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob186(structIterations, A);
#else
    zerorob186(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("186,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob187, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob187(structIterations, A);
#else
    zerorob187(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("187,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob188, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob188(structIterations, A);
#else
    zerorob188(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("188,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob189, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob189(structIterations, A);
#else
    zerorob189(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("189,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob190, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob190(structIterations, A);
#else
    zerorob190(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("190,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob191, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob191(structIterations, A);
#else
    zerorob191(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("191,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob192, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob192(structIterations, A);
#else
    zerorob192(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("192,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob193, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob193(structIterations, A);
#else
    zerorob193(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("193,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob194, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob194(structIterations, A);
#else
    zerorob194(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("194,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob195, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob195(structIterations, A);
#else
    zerorob195(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("195,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob196, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob196(structIterations, A);
#else
    zerorob196(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("196,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob197, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob197(structIterations, A);
#else
    zerorob197(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("197,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob198, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob198(structIterations, A);
#else
    zerorob198(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("198,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob199, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob199(structIterations, A);
#else
    zerorob199(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("199,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob200, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob200(structIterations, A);
#else
    zerorob200(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("200,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob201, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob201(structIterations, A);
#else
    zerorob201(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("201,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob202, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob202(structIterations, A);
#else
    zerorob202(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("202,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob203, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob203(structIterations, A);
#else
    zerorob203(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("203,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob204, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob204(structIterations, A);
#else
    zerorob204(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("204,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob205, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob205(structIterations, A);
#else
    zerorob205(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("205,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob206, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob206(structIterations, A);
#else
    zerorob206(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("206,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob207, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob207(structIterations, A);
#else
    zerorob207(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("207,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob208, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob208(structIterations, A);
#else
    zerorob208(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("208,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob209, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob209(structIterations, A);
#else
    zerorob209(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("209,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob210, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob210(structIterations, A);
#else
    zerorob210(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("210,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob211, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob211(structIterations, A);
#else
    zerorob211(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("211,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob212, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob212(structIterations, A);
#else
    zerorob212(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("212,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob213, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob213(structIterations, A);
#else
    zerorob213(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("213,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob214, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob214(structIterations, A);
#else
    zerorob214(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("214,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob215, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob215(structIterations, A);
#else
    zerorob215(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("215,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob216, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob216(structIterations, A);
#else
    zerorob216(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("216,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob217, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob217(structIterations, A);
#else
    zerorob217(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("217,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob218, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob218(structIterations, A);
#else
    zerorob218(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("218,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob219, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob219(structIterations, A);
#else
    zerorob219(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("219,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob220, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob220(structIterations, A);
#else
    zerorob220(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("220,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob221, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob221(structIterations, A);
#else
    zerorob221(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("221,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob222, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob222(structIterations, A);
#else
    zerorob222(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("222,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob223, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob223(structIterations, A);
#else
    zerorob223(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("223,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob224, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob224(structIterations, A);
#else
    zerorob224(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("224,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob225, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob225(structIterations, A);
#else
    zerorob225(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("225,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob226, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob226(structIterations, A);
#else
    zerorob226(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("226,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob227, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob227(structIterations, A);
#else
    zerorob227(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("227,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob228, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob228(structIterations, A);
#else
    zerorob228(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("228,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob229, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob229(structIterations, A);
#else
    zerorob229(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("229,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob230, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob230(structIterations, A);
#else
    zerorob230(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("230,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob231, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob231(structIterations, A);
#else
    zerorob231(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("231,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob232, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob232(structIterations, A);
#else
    zerorob232(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("232,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob233, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob233(structIterations, A);
#else
    zerorob233(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("233,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob234, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob234(structIterations, A);
#else
    zerorob234(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("234,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob235, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob235(structIterations, A);
#else
    zerorob235(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("235,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob236, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob236(structIterations, A);
#else
    zerorob236(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("236,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob237, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob237(structIterations, A);
#else
    zerorob237(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("237,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob238, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob238(structIterations, A);
#else
    zerorob238(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("238,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob239, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob239(structIterations, A);
#else
    zerorob239(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("239,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob240, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob240(structIterations, A);
#else
    zerorob240(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("240,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob241, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob241(structIterations, A);
#else
    zerorob241(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("241,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob242, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob242(structIterations, A);
#else
    zerorob242(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("242,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob243, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob243(structIterations, A);
#else
    zerorob243(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("243,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob244, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob244(structIterations, A);
#else
    zerorob244(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("244,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob245, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob245(structIterations, A);
#else
    zerorob245(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("245,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob246, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob246(structIterations, A);
#else
    zerorob246(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("246,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob247, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob247(structIterations, A);
#else
    zerorob247(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("247,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob248, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob248(structIterations, A);
#else
    zerorob248(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("248,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob249, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob249(structIterations, A);
#else
    zerorob249(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("249,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob250, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob250(structIterations, A);
#else
    zerorob250(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("250,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob251, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob251(structIterations, A);
#else
    zerorob251(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("251,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob252, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob252(structIterations, A);
#else
    zerorob252(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("252,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob253, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob253(structIterations, A);
#else
    zerorob253(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("253,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob254, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob254(structIterations, A);
#else
    zerorob254(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("254,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob255, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob255(structIterations, A);
#else
    zerorob255(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("255,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob256, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob256(structIterations, A);
#else
    zerorob256(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("256,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob257, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob257(structIterations, A);
#else
    zerorob257(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("257,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob258, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob258(structIterations, A);
#else
    zerorob258(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("258,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob259, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob259(structIterations, A);
#else
    zerorob259(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("259,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob260, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob260(structIterations, A);
#else
    zerorob260(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("260,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob261, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob261(structIterations, A);
#else
    zerorob261(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("261,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob262, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob262(structIterations, A);
#else
    zerorob262(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("262,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob263, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob263(structIterations, A);
#else
    zerorob263(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("263,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob264, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob264(structIterations, A);
#else
    zerorob264(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("264,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob265, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob265(structIterations, A);
#else
    zerorob265(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("265,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob266, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob266(structIterations, A);
#else
    zerorob266(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("266,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob267, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob267(structIterations, A);
#else
    zerorob267(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("267,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob268, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob268(structIterations, A);
#else
    zerorob268(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("268,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob269, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob269(structIterations, A);
#else
    zerorob269(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("269,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob270, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob270(structIterations, A);
#else
    zerorob270(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("270,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob271, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob271(structIterations, A);
#else
    zerorob271(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("271,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob272, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob272(structIterations, A);
#else
    zerorob272(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("272,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob273, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob273(structIterations, A);
#else
    zerorob273(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("273,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob274, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob274(structIterations, A);
#else
    zerorob274(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("274,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob275, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob275(structIterations, A);
#else
    zerorob275(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("275,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob276, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob276(structIterations, A);
#else
    zerorob276(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("276,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob277, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob277(structIterations, A);
#else
    zerorob277(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("277,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob278, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob278(structIterations, A);
#else
    zerorob278(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("278,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob279, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob279(structIterations, A);
#else
    zerorob279(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("279,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob280, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob280(structIterations, A);
#else
    zerorob280(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("280,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob281, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob281(structIterations, A);
#else
    zerorob281(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("281,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob282, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob282(structIterations, A);
#else
    zerorob282(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("282,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob283, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob283(structIterations, A);
#else
    zerorob283(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("283,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob284, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob284(structIterations, A);
#else
    zerorob284(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("284,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob285, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob285(structIterations, A);
#else
    zerorob285(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("285,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob286, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob286(structIterations, A);
#else
    zerorob286(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("286,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob287, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob287(structIterations, A);
#else
    zerorob287(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("287,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob288, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob288(structIterations, A);
#else
    zerorob288(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("288,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob289, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob289(structIterations, A);
#else
    zerorob289(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("289,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob290, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob290(structIterations, A);
#else
    zerorob290(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("290,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob291, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob291(structIterations, A);
#else
    zerorob291(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("291,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob292, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob292(structIterations, A);
#else
    zerorob292(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("292,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob293, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob293(structIterations, A);
#else
    zerorob293(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("293,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob294, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob294(structIterations, A);
#else
    zerorob294(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("294,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob295, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob295(structIterations, A);
#else
    zerorob295(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("295,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob296, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob296(structIterations, A);
#else
    zerorob296(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("296,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob297, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob297(structIterations, A);
#else
    zerorob297(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("297,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob298, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob298(structIterations, A);
#else
    zerorob298(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("298,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob299, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob299(structIterations, A);
#else
    zerorob299(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("299,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob300, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob300(structIterations, A);
#else
    zerorob300(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("300,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob301, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob301(structIterations, A);
#else
    zerorob301(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("301,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob302, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob302(structIterations, A);
#else
    zerorob302(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("302,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob303, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob303(structIterations, A);
#else
    zerorob303(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("303,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob304, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob304(structIterations, A);
#else
    zerorob304(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("304,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob305, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob305(structIterations, A);
#else
    zerorob305(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("305,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob306, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob306(structIterations, A);
#else
    zerorob306(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("306,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob307, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob307(structIterations, A);
#else
    zerorob307(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("307,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob308, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob308(structIterations, A);
#else
    zerorob308(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("308,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob309, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob309(structIterations, A);
#else
    zerorob309(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("309,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob310, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob310(structIterations, A);
#else
    zerorob310(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("310,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob311, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob311(structIterations, A);
#else
    zerorob311(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("311,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob312, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob312(structIterations, A);
#else
    zerorob312(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("312,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob313, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob313(structIterations, A);
#else
    zerorob313(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("313,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob314, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob314(structIterations, A);
#else
    zerorob314(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("314,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob315, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob315(structIterations, A);
#else
    zerorob315(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("315,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob316, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob316(structIterations, A);
#else
    zerorob316(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("316,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob317, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob317(structIterations, A);
#else
    zerorob317(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("317,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob318, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob318(structIterations, A);
#else
    zerorob318(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("318,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob319, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob319(structIterations, A);
#else
    zerorob319(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("319,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob320, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob320(structIterations, A);
#else
    zerorob320(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("320,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob321, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob321(structIterations, A);
#else
    zerorob321(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("321,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob322, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob322(structIterations, A);
#else
    zerorob322(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("322,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob323, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob323(structIterations, A);
#else
    zerorob323(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("323,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob324, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob324(structIterations, A);
#else
    zerorob324(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("324,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob325, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob325(structIterations, A);
#else
    zerorob325(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("325,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob326, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob326(structIterations, A);
#else
    zerorob326(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("326,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob327, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob327(structIterations, A);
#else
    zerorob327(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("327,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob328, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob328(structIterations, A);
#else
    zerorob328(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("328,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob329, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob329(structIterations, A);
#else
    zerorob329(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("329,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob330, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob330(structIterations, A);
#else
    zerorob330(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("330,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob331, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob331(structIterations, A);
#else
    zerorob331(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("331,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob332, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob332(structIterations, A);
#else
    zerorob332(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("332,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob333, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob333(structIterations, A);
#else
    zerorob333(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("333,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob334, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob334(structIterations, A);
#else
    zerorob334(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("334,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob335, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob335(structIterations, A);
#else
    zerorob335(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("335,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob336, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob336(structIterations, A);
#else
    zerorob336(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("336,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob337, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob337(structIterations, A);
#else
    zerorob337(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("337,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob338, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob338(structIterations, A);
#else
    zerorob338(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("338,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob339, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob339(structIterations, A);
#else
    zerorob339(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("339,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob340, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob340(structIterations, A);
#else
    zerorob340(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("340,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob341, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob341(structIterations, A);
#else
    zerorob341(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("341,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob342, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob342(structIterations, A);
#else
    zerorob342(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("342,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob343, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob343(structIterations, A);
#else
    zerorob343(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("343,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob344, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob344(structIterations, A);
#else
    zerorob344(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("344,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob345, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob345(structIterations, A);
#else
    zerorob345(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("345,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob346, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob346(structIterations, A);
#else
    zerorob346(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("346,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob347, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob347(structIterations, A);
#else
    zerorob347(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("347,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob348, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob348(structIterations, A);
#else
    zerorob348(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("348,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob349, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob349(structIterations, A);
#else
    zerorob349(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("349,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob350, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob350(structIterations, A);
#else
    zerorob350(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("350,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob351, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob351(structIterations, A);
#else
    zerorob351(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("351,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob352, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob352(structIterations, A);
#else
    zerorob352(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("352,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob353, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob353(structIterations, A);
#else
    zerorob353(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("353,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob354, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob354(structIterations, A);
#else
    zerorob354(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("354,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob355, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob355(structIterations, A);
#else
    zerorob355(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("355,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob356, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob356(structIterations, A);
#else
    zerorob356(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("356,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob357, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob357(structIterations, A);
#else
    zerorob357(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("357,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob358, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob358(structIterations, A);
#else
    zerorob358(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("358,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob359, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob359(structIterations, A);
#else
    zerorob359(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("359,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob360, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob360(structIterations, A);
#else
    zerorob360(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("360,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob361, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob361(structIterations, A);
#else
    zerorob361(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("361,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob362, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob362(structIterations, A);
#else
    zerorob362(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("362,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob363, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob363(structIterations, A);
#else
    zerorob363(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("363,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob364, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob364(structIterations, A);
#else
    zerorob364(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("364,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob365, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob365(structIterations, A);
#else
    zerorob365(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("365,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob366, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob366(structIterations, A);
#else
    zerorob366(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("366,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob367, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob367(structIterations, A);
#else
    zerorob367(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("367,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob368, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob368(structIterations, A);
#else
    zerorob368(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("368,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob369, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob369(structIterations, A);
#else
    zerorob369(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("369,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob370, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob370(structIterations, A);
#else
    zerorob370(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("370,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob371, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob371(structIterations, A);
#else
    zerorob371(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("371,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob372, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob372(structIterations, A);
#else
    zerorob372(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("372,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob373, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob373(structIterations, A);
#else
    zerorob373(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("373,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob374, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob374(structIterations, A);
#else
    zerorob374(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("374,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob375, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob375(structIterations, A);
#else
    zerorob375(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("375,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob376, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob376(structIterations, A);
#else
    zerorob376(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("376,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob377, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob377(structIterations, A);
#else
    zerorob377(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("377,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob378, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob378(structIterations, A);
#else
    zerorob378(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("378,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob379, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob379(structIterations, A);
#else
    zerorob379(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("379,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob380, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob380(structIterations, A);
#else
    zerorob380(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("380,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob381, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob381(structIterations, A);
#else
    zerorob381(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("381,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob382, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob382(structIterations, A);
#else
    zerorob382(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("382,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob383, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob383(structIterations, A);
#else
    zerorob383(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("383,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob384, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob384(structIterations, A);
#else
    zerorob384(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("384,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob385, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob385(structIterations, A);
#else
    zerorob385(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("385,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob386, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob386(structIterations, A);
#else
    zerorob386(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("386,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob387, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob387(structIterations, A);
#else
    zerorob387(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("387,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob388, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob388(structIterations, A);
#else
    zerorob388(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("388,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob389, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob389(structIterations, A);
#else
    zerorob389(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("389,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob390, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob390(structIterations, A);
#else
    zerorob390(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("390,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob391, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob391(structIterations, A);
#else
    zerorob391(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("391,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob392, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob392(structIterations, A);
#else
    zerorob392(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("392,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob393, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob393(structIterations, A);
#else
    zerorob393(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("393,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob394, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob394(structIterations, A);
#else
    zerorob394(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("394,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob395, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob395(structIterations, A);
#else
    zerorob395(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("395,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob396, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob396(structIterations, A);
#else
    zerorob396(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("396,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob397, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob397(structIterations, A);
#else
    zerorob397(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("397,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob398, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob398(structIterations, A);
#else
    zerorob398(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("398,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob399, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob399(structIterations, A);
#else
    zerorob399(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("399,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob400, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob400(structIterations, A);
#else
    zerorob400(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("400,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob401, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob401(structIterations, A);
#else
    zerorob401(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("401,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob402, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob402(structIterations, A);
#else
    zerorob402(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("402,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob403, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob403(structIterations, A);
#else
    zerorob403(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("403,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob404, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob404(structIterations, A);
#else
    zerorob404(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("404,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob405, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob405(structIterations, A);
#else
    zerorob405(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("405,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob406, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob406(structIterations, A);
#else
    zerorob406(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("406,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob407, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob407(structIterations, A);
#else
    zerorob407(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("407,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob408, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob408(structIterations, A);
#else
    zerorob408(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("408,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob409, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob409(structIterations, A);
#else
    zerorob409(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("409,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob410, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob410(structIterations, A);
#else
    zerorob410(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("410,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob411, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob411(structIterations, A);
#else
    zerorob411(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("411,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob412, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob412(structIterations, A);
#else
    zerorob412(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("412,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob413, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob413(structIterations, A);
#else
    zerorob413(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("413,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob414, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob414(structIterations, A);
#else
    zerorob414(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("414,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob415, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob415(structIterations, A);
#else
    zerorob415(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("415,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob416, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob416(structIterations, A);
#else
    zerorob416(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("416,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob417, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob417(structIterations, A);
#else
    zerorob417(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("417,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob418, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob418(structIterations, A);
#else
    zerorob418(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("418,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob419, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob419(structIterations, A);
#else
    zerorob419(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("419,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob420, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob420(structIterations, A);
#else
    zerorob420(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("420,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob421, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob421(structIterations, A);
#else
    zerorob421(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("421,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob422, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob422(structIterations, A);
#else
    zerorob422(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("422,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob423, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob423(structIterations, A);
#else
    zerorob423(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("423,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob424, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob424(structIterations, A);
#else
    zerorob424(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("424,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob425, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob425(structIterations, A);
#else
    zerorob425(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("425,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob426, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob426(structIterations, A);
#else
    zerorob426(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("426,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob427, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob427(structIterations, A);
#else
    zerorob427(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("427,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob428, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob428(structIterations, A);
#else
    zerorob428(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("428,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob429, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob429(structIterations, A);
#else
    zerorob429(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("429,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob430, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob430(structIterations, A);
#else
    zerorob430(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("430,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob431, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob431(structIterations, A);
#else
    zerorob431(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("431,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob432, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob432(structIterations, A);
#else
    zerorob432(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("432,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob433, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob433(structIterations, A);
#else
    zerorob433(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("433,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob434, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob434(structIterations, A);
#else
    zerorob434(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("434,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob435, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob435(structIterations, A);
#else
    zerorob435(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("435,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob436, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob436(structIterations, A);
#else
    zerorob436(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("436,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob437, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob437(structIterations, A);
#else
    zerorob437(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("437,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob438, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob438(structIterations, A);
#else
    zerorob438(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("438,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob439, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob439(structIterations, A);
#else
    zerorob439(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("439,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob440, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob440(structIterations, A);
#else
    zerorob440(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("440,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob441, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob441(structIterations, A);
#else
    zerorob441(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("441,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob442, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob442(structIterations, A);
#else
    zerorob442(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("442,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob443, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob443(structIterations, A);
#else
    zerorob443(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("443,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob444, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob444(structIterations, A);
#else
    zerorob444(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("444,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob445, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob445(structIterations, A);
#else
    zerorob445(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("445,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob446, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob446(structIterations, A);
#else
    zerorob446(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("446,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob447, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob447(structIterations, A);
#else
    zerorob447(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("447,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob448, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob448(structIterations, A);
#else
    zerorob448(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("448,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob449, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob449(structIterations, A);
#else
    zerorob449(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("449,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob450, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob450(structIterations, A);
#else
    zerorob450(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("450,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob451, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob451(structIterations, A);
#else
    zerorob451(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("451,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob452, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob452(structIterations, A);
#else
    zerorob452(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("452,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob453, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob453(structIterations, A);
#else
    zerorob453(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("453,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob454, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob454(structIterations, A);
#else
    zerorob454(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("454,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob455, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob455(structIterations, A);
#else
    zerorob455(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("455,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob456, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob456(structIterations, A);
#else
    zerorob456(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("456,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob457, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob457(structIterations, A);
#else
    zerorob457(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("457,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob458, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob458(structIterations, A);
#else
    zerorob458(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("458,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob459, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob459(structIterations, A);
#else
    zerorob459(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("459,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob460, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob460(structIterations, A);
#else
    zerorob460(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("460,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob461, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob461(structIterations, A);
#else
    zerorob461(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("461,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob462, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob462(structIterations, A);
#else
    zerorob462(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("462,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob463, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob463(structIterations, A);
#else
    zerorob463(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("463,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob464, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob464(structIterations, A);
#else
    zerorob464(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("464,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob465, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob465(structIterations, A);
#else
    zerorob465(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("465,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob466, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob466(structIterations, A);
#else
    zerorob466(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("466,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob467, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob467(structIterations, A);
#else
    zerorob467(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("467,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob468, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob468(structIterations, A);
#else
    zerorob468(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("468,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob469, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob469(structIterations, A);
#else
    zerorob469(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("469,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob470, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob470(structIterations, A);
#else
    zerorob470(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("470,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob471, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob471(structIterations, A);
#else
    zerorob471(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("471,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob472, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob472(structIterations, A);
#else
    zerorob472(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("472,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob473, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob473(structIterations, A);
#else
    zerorob473(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("473,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob474, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob474(structIterations, A);
#else
    zerorob474(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("474,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob475, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob475(structIterations, A);
#else
    zerorob475(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("475,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob476, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob476(structIterations, A);
#else
    zerorob476(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("476,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob477, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob477(structIterations, A);
#else
    zerorob477(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("477,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob478, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob478(structIterations, A);
#else
    zerorob478(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("478,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob479, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob479(structIterations, A);
#else
    zerorob479(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("479,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob480, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob480(structIterations, A);
#else
    zerorob480(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("480,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob481, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob481(structIterations, A);
#else
    zerorob481(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("481,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob482, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob482(structIterations, A);
#else
    zerorob482(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("482,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob483, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob483(structIterations, A);
#else
    zerorob483(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("483,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob484, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob484(structIterations, A);
#else
    zerorob484(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("484,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob485, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob485(structIterations, A);
#else
    zerorob485(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("485,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob486, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob486(structIterations, A);
#else
    zerorob486(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("486,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob487, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob487(structIterations, A);
#else
    zerorob487(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("487,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob488, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob488(structIterations, A);
#else
    zerorob488(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("488,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob489, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob489(structIterations, A);
#else
    zerorob489(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("489,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob490, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob490(structIterations, A);
#else
    zerorob490(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("490,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob491, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob491(structIterations, A);
#else
    zerorob491(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("491,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob492, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob492(structIterations, A);
#else
    zerorob492(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("492,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob493, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob493(structIterations, A);
#else
    zerorob493(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("493,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob494, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob494(structIterations, A);
#else
    zerorob494(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("494,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob495, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob495(structIterations, A);
#else
    zerorob495(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("495,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob496, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob496(structIterations, A);
#else
    zerorob496(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("496,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob497, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob497(structIterations, A);
#else
    zerorob497(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("497,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob498, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob498(structIterations, A);
#else
    zerorob498(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("498,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob499, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob499(structIterations, A);
#else
    zerorob499(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("499,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob500, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob500(structIterations, A);
#else
    zerorob500(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("500,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob501, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob501(structIterations, A);
#else
    zerorob501(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("501,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob502, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob502(structIterations, A);
#else
    zerorob502(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("502,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob503, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob503(structIterations, A);
#else
    zerorob503(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("503,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob504, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob504(structIterations, A);
#else
    zerorob504(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("504,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob505, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob505(structIterations, A);
#else
    zerorob505(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("505,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob506, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob506(structIterations, A);
#else
    zerorob506(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("506,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob507, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob507(structIterations, A);
#else
    zerorob507(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("507,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob508, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob508(structIterations, A);
#else
    zerorob508(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("508,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob509, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob509(structIterations, A);
#else
    zerorob509(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("509,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob510, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob510(structIterations, A);
#else
    zerorob510(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("510,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob511, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob511(structIterations, A);
#else
    zerorob511(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("511,%f\n", latency);

    gettimeofday(&startTv, &startTz);
#ifndef __MINGW32__
    if (threads > 1) {
        struct ThreadData testThreadData;
        pthread_t *testThreads = (pthread_t *)malloc(threads * sizeof(pthread_t));
        testThreadData.A = A;
        testThreadData.B = B;
        testThreadData.fpArr = fpArr;
        testThreadData.list_size = list_size;
        testThreadData.structIterations = structIterations;
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
            pthread_create(testThreads + threadIdx, NULL, ThreadLaunch_zerorob512, &testThreadData);
        }
        for (int threadIdx = 0; threadIdx < threads; threadIdx++) {
             pthread_join(testThreads[threadIdx], NULL);
        }
        free(testThreads);
    } else 
        zerorob512(structIterations, A);
#else
    zerorob512(structIterations, A);
#endif
    gettimeofday(&endTv, &endTz);
    time_diff_ms = 1000 * (endTv.tv_sec - startTv.tv_sec) + ((endTv.tv_usec - startTv.tv_usec) / 1000);
    latency = 1e6 * (float)time_diff_ms / (float)(structIterations);
    printf("512,%f\n", latency);

  }

  free(A); free(B); free(fpArr);
  }
  return 0; }
